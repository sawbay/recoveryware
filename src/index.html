
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Recovery Ware</title>
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%232563eb'/%3E%3Cstop offset='100%25' stop-color='%230c4a6e'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='12' fill='url(%23g)'/%3E%3Cpath fill='white' d='M32 18a8 8 0 0 1 8 8v4h2a2 2 0 0 1 2 2v18a2 2 0 0 1-2 2H22a2 2 0 0 1-2-2V32a2 2 0 0 1 2-2h2v-4a8 8 0 0 1 8-8zm0 4a4 4 0 0 0-4 4v4h8v-4a4 4 0 0 0-4-4zm0 12a4 4 0 1 0 0 8 4 4 0 0 0 0-8z'/%3E%3C/svg%3E"
    />
    <style>
      :root {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #1f2933;
        background-color: #f8fafc;
      }
      body {
        margin: 0;
        padding: 0 1.5rem 3rem;
        max-width: 960px;
        margin-inline: auto;
      }
      header,
      footer {
        text-align: center;
        margin: 2rem 0;
      }
      main {
        display: grid;
        gap: 1.5rem;
      }
      .panel {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.08);
        display: grid;
        gap: 1rem;
      }
      label {
        display: grid;
        gap: 0.5rem;
        font-weight: 600;
      }
      input[type="password"],
      input[type="number"],
      textarea {
        padding: 0.65rem 0.75rem;
        border-radius: 8px;
        border: 1px solid #cbd5f5;
        font: inherit;
        resize: vertical;
      }
      textarea[readonly] {
        background: #f1f5f9;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      button {
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 0.6rem 1.2rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 12px rgba(37, 99, 235, 0.2);
      }
      button:disabled {
        background: #94a3b8;
        cursor: not-allowed;
        box-shadow: none;
      }
      #status {
        min-height: 1.5rem;
        font-weight: 600;
        color: #1d4ed8;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Recovery Ware</h1>
      <p>Encrypt or decrypt sensitive text with PBKDF2 + AES-GCM, then save or write it to an NFC tag.</p>
    </header>

    <main>
      <section class="panel">
        <h2>Inputs</h2>
        <label>
          Passphrase
          <input id="passphrase" type="password" autocomplete="new-password" />
        </label>
        <label>
          Confirm Passphrase
          <input id="passphrase-confirm" type="password" autocomplete="new-password" />
        </label>
        <label>
          PBKDF2 Iterations (min 100000)
          <input id="iterations" type="number" min="100000" value="600000" />
        </label>

        <label>
          Plaintext (for encryption)
          <textarea id="plaintext" rows="6" placeholder="Enter plaintext seed or other secret..."></textarea>
        </label>
        <div class="controls">
          <button id="encrypt-btn">Encrypt</button>
          <button id="decrypt-btn">Decrypt</button>
        </div>

        <label>
          Encrypted blob JSON (for decrypting or writing to NFC)
          <textarea id="ciphertext" rows="10" placeholder='{"version":1,"kdf":"PBKDF2",...}'></textarea>
        </label>
        <div class="controls">
          <button id="read-nfc-btn">Read from NFC</button>
          <button id="write-nfc-btn">Write to NFC</button>
          <button id="copy-ciphertext-btn">Copy</button>
        </div>

        <p id="status" role="status" aria-live="polite"></p>
      </section>
    </main>

    <footer>
      <p>Data never leaves your browser. Ensure you wipe downloaded plaintext files after use.</p>
    </footer>

    <script type="module">
      const DEFAULT_ITERATIONS = 600_000;
      const MIN_ITERATIONS = 100_000;

      function requireElement(id) {
        const el = document.getElementById(id);
        if (!el) throw new Error(`Missing required element #${id}`);
        return el;
      }

      window.addEventListener("DOMContentLoaded", () => {
        const elements = {
          passphrase: requireElement("passphrase"),
          passphraseConfirm: requireElement("passphrase-confirm"),
          iterations: requireElement("iterations"),
          plaintext: requireElement("plaintext"),
          ciphertext: requireElement("ciphertext"),
          encryptBtn: requireElement("encrypt-btn"),
          decryptBtn: requireElement("decrypt-btn"),
          copyCiphertextBtn: requireElement("copy-ciphertext-btn"),
          readNfcBtn: requireElement("read-nfc-btn"),
          writeNfcBtn: requireElement("write-nfc-btn"),
          status: requireElement("status"),
        };

        function setStatus(message, tone = "info") {
          elements.status.textContent = message;
          elements.status.style.color =
            tone === "error" ? "#dc2626" : tone === "success" ? "#15803d" : "#1d4ed8";
        }

        function toBase64(u8) {
          const CHUNK_SIZE = 0x8000;
          let binary = "";
          for (let i = 0; i < u8.length; i += CHUNK_SIZE) {
            const chunk = u8.subarray(i, i + CHUNK_SIZE);
            binary += String.fromCharCode(...chunk);
          }
          return btoa(binary);
        }

        function fromBase64(str) {
          const binary = atob(str);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        }

        function encodeUtf8(s) {
          return new TextEncoder().encode(s);
        }

        function decodeUtf8(bytes) {
          return new TextDecoder().decode(bytes);
        }

        function dataViewToString(data) {
          if (data instanceof DataView) {
            return new TextDecoder().decode(
              new Uint8Array(data.buffer, data.byteOffset, data.byteLength),
            );
          }
          if (data instanceof ArrayBuffer) {
            return new TextDecoder().decode(new Uint8Array(data));
          }
          if (data instanceof Uint8Array) {
            return new TextDecoder().decode(data);
          }
          if (typeof data === "string") {
            return data;
          }
          return "";
        }

        function parseIterations(value) {
          if (!value) return DEFAULT_ITERATIONS;
          const parsed = Number(value);
          if (!Number.isFinite(parsed) || parsed < MIN_ITERATIONS) {
            throw new Error(`Iterations must be a number ≥ ${MIN_ITERATIONS}.`);
          }
          return Math.floor(parsed);
        }

        async function deriveKey(passphrase, salt, iterations) {
          const baseKey = await crypto.subtle.importKey(
            "raw",
            encodeUtf8(passphrase),
            { name: "PBKDF2" },
            false,
            ["deriveKey"],
          );
          return await crypto.subtle.deriveKey(
            {
              name: "PBKDF2",
              hash: "SHA-256",
              salt,
              iterations,
            },
            baseKey,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"],
          );
        }

        async function encryptPlaintext(plaintext, passphrase, iterations) {
          if (!plaintext.trim()) throw new Error("Plaintext input is empty.");
          const salt = crypto.getRandomValues(new Uint8Array(16));
          const nonce = crypto.getRandomValues(new Uint8Array(12));
          const key = await deriveKey(passphrase, salt, iterations);

          const ciphertext = new Uint8Array(
            await crypto.subtle.encrypt(
              { name: "AES-GCM", iv: nonce },
              key,
              encodeUtf8(plaintext),
            ),
          );

          const blob = {
            version: 1,
            kdf: "PBKDF2",
            hash: "SHA-256",
            iterations,
            salt_b64: toBase64(salt),
            nonce_b64: toBase64(nonce),
            ciphertext_b64: toBase64(ciphertext),
          };

          return JSON.stringify(blob, null, 2);
        }

        async function decryptBlob(blobJson, passphrase) {
          if (!blobJson.trim()) throw new Error("Encrypted blob input is empty.");
          const blob = JSON.parse(blobJson);

          if (blob.kdf !== "PBKDF2" || blob.hash !== "SHA-256") {
            throw new Error("Unsupported KDF parameters.");
          }

          const salt = fromBase64(blob.salt_b64);
          const nonce = fromBase64(blob.nonce_b64);
          const ciphertext = fromBase64(blob.ciphertext_b64);
          const key = await deriveKey(passphrase, salt, blob.iterations);

          const plaintextBytes = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: nonce },
            key,
            ciphertext,
          );
          return decodeUtf8(new Uint8Array(plaintextBytes));
        }

        function getPassphraseForEncrypt() {
          const pw = elements.passphrase.value;
          const confirm = elements.passphraseConfirm.value;
          if (!pw) throw new Error("Passphrase is required.");
          if (pw.length < 4) throw new Error("Passphrase must be at least 4 characters.");
          if (pw !== confirm) throw new Error("Passphrases do not match.");
          return pw;
        }

        function getPassphraseForDecrypt() {
          const pw = elements.passphrase.value;
          const confirm = elements.passphraseConfirm.value;
          if (!pw) throw new Error("Passphrase is required.");
          if (confirm && confirm !== pw) {
            throw new Error("Passphrase confirmation does not match.");
          }
          return pw;
        }

        async function handleEncrypt() {
          try {
            setStatus("Encrypting…");
            const passphrase = getPassphraseForEncrypt();
            const iterations = parseIterations(elements.iterations.value);
            const plaintext = elements.plaintext.value;
            const blobJson = await encryptPlaintext(plaintext, passphrase, iterations);
            elements.ciphertext.value = blobJson;
            setStatus("Encryption complete.", "success");
          } catch (err) {
            console.error(err);
            setStatus(err.message || String(err), "error");
          }
        }

        async function handleDecrypt() {
          try {
            setStatus("Decrypting…");
            const passphrase = getPassphraseForDecrypt();
            const blobJson = elements.ciphertext.value;
            const plaintext = await decryptBlob(blobJson, passphrase);
            elements.plaintext.value = plaintext;
            setStatus("Decryption complete.", "success");
          } catch (err) {
            console.error(err);
            setStatus(err.message || String(err), "error");
          }
        }

        async function handleWriteNfc() {
          if (!("NDEFReader" in window)) {
            setStatus("Web NFC not supported on this device.", "error");
            return;
          }
          const blobJson = elements.ciphertext.value.trim();
          if (!blobJson) {
            setStatus("Encrypt text first before writing to NFC.", "error");
            return;
          }
          try {
            setStatus("Bring an NFC tag close to write…");
            const ndef = new NDEFReader();
            await ndef.write({
              records: [
                {
                  recordType: "mime",
                  mediaType: "application/json",
                  data: blobJson,
                },
              ],
            });
            setStatus("Encrypted blob written to NFC tag.", "success");
          } catch (err) {
            console.error(err);
            setStatus(err.message || "Failed to write to NFC.", "error");
          }
        }

        elements.encryptBtn.addEventListener("click", handleEncrypt);
        elements.decryptBtn.addEventListener("click", handleDecrypt);
        elements.copyCiphertextBtn.addEventListener("click", async () => {
          const data = elements.ciphertext.value.trim();
          if (!data) {
            setStatus("No encrypted data to copy.", "error");
            return;
          }
          try {
            await navigator.clipboard.writeText(data);
            setStatus("Encrypted blob copied to clipboard.", "success");
          } catch (err) {
            console.error(err);
            setStatus("Clipboard write failed. Copy manually.", "error");
          }
        });

        async function handleReadNfc() {
          if (!("NDEFReader" in window)) {
            setStatus("Web NFC not supported on this device.", "error");
            return;
          }
          try {
            setStatus("Bring an NFC tag close to read…");
            const ndef = new NDEFReader();
            const readPromise = new Promise((resolve, reject) => {
              const onReading = (event) => {
                try {
                  const records = event.message.records;
                  if (!records.length) {
                    reject(new Error("No records found on tag."));
                    return;
                  }
                  const record = records[0];
                  const payload = dataViewToString(record.data);
                  resolve(payload);
                } catch (err) {
                  reject(err);
                }
              };
              const onError = () => reject(new Error("Failed to read NFC tag."));
              ndef.addEventListener("reading", onReading, { once: true });
              ndef.addEventListener("readingerror", onError, { once: true });
            });
            await ndef.scan();
            const payload = await readPromise;
            if (!payload || typeof payload !== "string") {
              throw new Error("No readable data on tag.");
            }
            elements.ciphertext.value = payload;
            setStatus("Encrypted blob loaded from NFC tag.", "success");
          } catch (err) {
            console.error(err);
            setStatus(err.message || "Failed to read from NFC.", "error");
          }
        }

        elements.writeNfcBtn.addEventListener("click", handleWriteNfc);
        elements.readNfcBtn.addEventListener("click", handleReadNfc);

        if (!("NDEFReader" in window)) {
          elements.writeNfcBtn.disabled = true;
          elements.writeNfcBtn.title = "Web NFC is only available on supported Android browsers.";
          elements.readNfcBtn.disabled = true;
          elements.readNfcBtn.title = "Web NFC is only available on supported Android browsers.";
        }

        setStatus("Ready.");
      });
    </script>
  </body>
</html>
