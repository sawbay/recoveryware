<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Recovery Ware</title>
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%232563eb'/%3E%3Cstop offset='100%25' stop-color='%230c4a6e'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='12' fill='url(%23g)'/%3E%3Cpath fill='white' d='M32 18a8 8 0 0 1 8 8v4h2a2 2 0 0 1 2 2v18a2 2 0 0 1-2 2H22a2 2 0 0 1-2-2V32a2 2 0 0 1 2-2h2v-4a8 8 0 0 1 8-8zm0 4a4 4 0 0 0-4 4v4h8v-4a4 4 0 0 0-4-4zm0 12a4 4 0 1 0 0 8 4 4 0 0 0 0-8z'/%3E%3C/svg%3E"
    />
    <style>
      :root {
        font-family:
          "SF Pro Text",
          "SF Pro Display",
          -apple-system,
          BlinkMacSystemFont,
          "Helvetica Neue",
          "Segoe UI",
          sans-serif;
        color: #f9fafb;
        background-color: #090b11;
        line-height: 1.5;
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: clamp(1.5rem, 5vw, 3rem);
        min-height: 100vh;
        background:
          radial-gradient(circle at 20% 20%, rgba(120, 119, 198, 0.18), transparent 60%),
          radial-gradient(circle at 80% 0%, rgba(56, 189, 248, 0.12), transparent 50%),
          radial-gradient(circle at 0% 80%, rgba(192, 132, 252, 0.15), transparent 55%),
          #040509;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        color: inherit;
      }
      .shell {
        width: min(100%, 760px);
        display: grid;
        gap: clamp(1.5rem, 4vw, 2.75rem);
      }
      header {
        text-align: center;
        display: grid;
        gap: 0.5rem;
        color: #f8fafc;
      }
      header h1 {
        margin: 0;
        font-size: clamp(2.4rem, 5vw, 3.1rem);
        letter-spacing: -0.03em;
        color: #e0f2fe;
        text-shadow:
          0 12px 30px rgba(37, 99, 235, 0.3),
          0 0 18px rgba(59, 130, 246, 0.45),
          0 0 30px rgba(168, 85, 247, 0.35);
      }
      header p {
        margin: 0;
        color: rgba(226, 232, 240, 0.72);
        max-width: 48ch;
        justify-self: center;
      }
      main {
        display: grid;
        gap: 1.75rem;
        flex: 1 0 auto;
      }
      .tab-bar {
        display: inline-flex;
        background: rgba(148, 163, 184, 0.12);
        border-radius: 999px;
        padding: 0.35rem;
        gap: 0.35rem;
        justify-self: center;
        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.16);
        backdrop-filter: blur(18px);
      }
      .tab-btn {
        border: none;
        background: transparent;
        color: rgba(226, 232, 240, 0.76);
        font-weight: 600;
        padding: 0.75rem 1.75rem;
        border-radius: 999px;
        cursor: pointer;
        transition: all 0.25s ease;
      }
      .tab-btn:focus-visible {
        outline: 2px solid rgba(148, 163, 184, 0.5);
        outline-offset: 3px;
      }
      .tab-btn:hover:not(.tab-btn--active) {
        background: rgba(148, 163, 184, 0.18);
        color: #f8fafc;
        transform: translateY(-1px);
      }
      .tab-btn--active {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.85), rgba(14, 165, 233, 0.85));
        color: #0a0c12;
        box-shadow:
          0 12px 30px rgba(56, 189, 248, 0.35),
          inset 0 0 0 1px rgba(241, 245, 249, 0.35);
      }
      .tab-panels {
        display: grid;
        gap: 1.75rem;
      }
      .tab-panel {
        display: none !important;
      }
      .tab-panel--active {
        display: grid !important;
      }
      .panel {
        background: rgba(15, 16, 24, 0.72);
        border-radius: 24px;
        padding: clamp(1.5rem, 4vw, 2.3rem);
        box-shadow:
          0 32px 80px rgba(2, 6, 23, 0.7),
          0 4px 20px rgba(15, 23, 42, 0.3),
          inset 0 1px 0 rgba(148, 163, 184, 0.08);
        border: 1px solid rgba(148, 163, 184, 0.18);
        backdrop-filter: blur(24px);
        display: grid;
        gap: 1.1rem;
      }
      @media (min-width: 768px) {
        .panel {
          padding: clamp(2rem, 3vw, 2.6rem);
        }
      }
      .section-header {
        display: grid;
        gap: 0.25rem;
      }
      .section-header h2 {
        margin: 0;
        font-size: 1.6rem;
        letter-spacing: -0.015em;
        color: #f8fafc;
      }
      .section-header p {
        margin: 0;
        color: rgba(226, 232, 240, 0.6);
        font-size: 0.95rem;
        line-height: 1.5;
      }
      label {
        display: grid;
        gap: 0.5rem;
        font-weight: 600;
        color: rgba(226, 232, 240, 0.94);
      }
      input[type="password"],
      input[type="number"],
      textarea {
        width: 100%;
        padding: 0.75rem 1rem;
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        font: inherit;
        background: rgba(15, 23, 42, 0.55);
        color: #f8fafc;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
        transition: border 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }
      input[type="password"]:focus-visible,
      input[type="number"]:focus-visible,
      textarea:focus-visible {
        outline: none;
        border-color: rgba(129, 140, 248, 0.65);
        box-shadow: 0 0 0 4px rgba(129, 140, 248, 0.15);
        background: rgba(20, 28, 48, 0.75);
      }
      textarea {
        resize: vertical;
        min-height: 8rem;
      }
      textarea[readonly] {
        background: rgba(15, 23, 42, 0.4);
        color: rgba(226, 232, 240, 0.65);
      }
      input[type="number"] {
        appearance: textfield;
      }
      input[type="number"]::-webkit-outer-spin-button,
      input[type="number"]::-webkit-inner-spin-button {
        margin: 0;
        appearance: none;
      }
      input::placeholder,
      textarea::placeholder {
        color: rgba(148, 163, 184, 0.6);
      }
      .helper-text {
        margin: 0;
        color: rgba(148, 163, 184, 0.72);
        font-size: 0.9rem;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.85rem;
      }
      .action-btn {
        background: linear-gradient(135deg, #6366f1, #0ea5e9);
        color: #0a0c12;
        border: none;
        border-radius: 16px;
        padding: 0.85rem 1.9rem;
        min-height: 3rem;
        font-weight: 600;
        letter-spacing: 0.01em;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.25s ease, filter 0.2s ease;
      }
      .action-btn:hover:not(:disabled),
      .action-btn:focus-visible:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 20px 40px rgba(14, 165, 233, 0.35);
        filter: brightness(1.08);
        outline: none;
      }
      .action-btn:disabled {
        background: rgba(148, 163, 184, 0.22);
        color: rgba(226, 232, 240, 0.4);
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .action-btn.secondary {
        background: rgba(148, 163, 184, 0.18);
        color: rgba(226, 232, 240, 0.9);
        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.25);
      }
      .action-btn.secondary:hover:not(:disabled),
      .action-btn.secondary:focus-visible:not(:disabled) {
        background: rgba(148, 163, 184, 0.28);
        box-shadow: inset 0 0 0 1px rgba(226, 232, 240, 0.22);
      }
      .stepper {
        display: grid;
        gap: 1rem;
      }
      .step-toolbar {
        display: flex;
        align-items: flex-end;
        gap: 1rem;
      }
      .step-toolbar [data-step-prev],
      .step-toolbar [data-step-next] {
        flex-shrink: 0;
      }
      .step-toolbar [data-step-next] {
        margin-left: auto;
      }
      .step-title {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.2rem;
        text-align: center;
      }
      .step-title-position {
        font-size: 0.85rem;
        color: rgba(203, 213, 225, 0.6);
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .step-title-name {
        font-weight: 600;
        font-size: 1.05rem;
        color: #f8fafc;
      }
      @media (min-width: 640px) {
        .step-title {
          text-align: left;
          align-items: flex-start;
        }
      }
      .step-panels {
        position: relative;
      }
      .step-panel {
        display: none;
        gap: 1rem;
        align-content: start;
      }
      .step-panel--active {
        display: grid;
      }
      #status {
        background: rgba(59, 130, 246, 0.18);
        border-radius: 18px;
        padding: 1rem 1.4rem;
        font-weight: 600;
        color: rgba(191, 219, 254, 0.95);
        text-align: center;
        backdrop-filter: blur(24px);
        box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.35);
      }
      footer {
        text-align: center;
        color: rgba(148, 163, 184, 0.65);
        margin-bottom: 1rem;
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header>
        <h1>Recovery Ware</h1>
        <p>Encrypt or decrypt sensitive text with PBKDF2 + AES-GCM, then save or write it to an NFC tag.</p>
      </header>

      <main>
        <div class="tab-bar" role="tablist" aria-label="Encrypt or decrypt">
          <button
            type="button"
            class="tab-btn tab-btn--active"
            data-tab-target="encrypt"
            role="tab"
            aria-controls="tab-encrypt"
            aria-selected="true"
            tabindex="0"
          >
            Encrypt
          </button>
          <button
            type="button"
            class="tab-btn"
            data-tab-target="decrypt"
            role="tab"
            aria-controls="tab-decrypt"
            aria-selected="false"
            tabindex="-1"
          >
            Decrypt
          </button>
        </div>
        <div class="tab-panels" id="tab-panels" data-active-tab="encrypt">
          <section
            class="panel tab-panel tab-panel--active"
            id="tab-encrypt"
            data-tab="encrypt"
            role="tabpanel"
            aria-label="Encrypt"
            aria-hidden="false"
          >
            <div class="section-header">
              <h2>Encrypt</h2>
            </div>
            <div class="stepper" id="workflow-encrypt">
              <div class="step-toolbar">
                <button type="button" class="action-btn secondary" data-step-prev disabled>Back</button>
                <div class="step-title">
                  <span class="step-title-position" data-step-position>Step 1 of 4</span>
                  <span class="step-title-name" data-step-name>Enter plain text</span>
                </div>
                <button type="button" class="action-btn" data-step-next>Next</button>
              </div>
              <div class="step-panels">
                <section
                  class="step-panel step-panel--active"
                  id="encrypt-step-0"
                  data-step-panel="0"
                  data-step-name="Enter plain text"
                  aria-hidden="false"
                >
                  <label>
                    Plaintext
                    <textarea
                      id="encrypt-plaintext"
                      rows="6"
                      placeholder="Enter plaintext seed or other secret..."
                    ></textarea>
                  </label>
                </section>

                <section
                  class="step-panel"
                  id="encrypt-step-1"
                  data-step-panel="1"
                  data-step-name="Passphrase (optional)"
                  hidden
                  aria-hidden="true"
                >
                  <p class="helper-text">Add a passphrase for stronger protection or leave blank to rely on device security.</p>
                  <label>
                    Passphrase
                    <input id="encrypt-passphrase" type="password" autocomplete="new-password" />
                  </label>
                  <label>
                    Confirm passphrase
                    <input id="encrypt-passphrase-confirm" type="password" autocomplete="new-password" />
                  </label>
                </section>

                <section
                  class="step-panel"
                  id="encrypt-step-2"
                  data-step-panel="2"
                  data-step-name="Iterations"
                  hidden
                  aria-hidden="true"
                >
                  <label>
                    PBKDF2 iterations
                    <input
                      id="iterations"
                      type="number"
                      min="100000"
                      value="600000"
                      inputmode="numeric"
                    />
                  </label>
                  <p class="helper-text">Defaults to 600,000 iterations for a balanced KDF. Higher counts strengthen brute-force resistance at the cost of speed.</p>
                </section>

                <section
                  class="step-panel"
                  id="encrypt-step-3"
                  data-step-panel="3"
                  data-step-name="Copy or write to NFC"
                  hidden
                  aria-hidden="true"
                >
                  <label>
                    Encrypted blob JSON
                    <textarea
                      id="ciphertext-encrypt"
                      rows="8"
                      placeholder='{"version":1,"kdf":"PBKDF2",...}'
                    ></textarea>
                  </label>
                  <div class="controls">
                    <button id="copy-ciphertext-btn" type="button" class="action-btn secondary">
                      Copy JSON
                    </button>
                    <button id="write-nfc-btn" type="button" class="action-btn secondary">
                      Write to NFC
                    </button>
                  </div>
                </section>
              </div>
            </div>
          </section>

          <section
            class="panel tab-panel"
            id="tab-decrypt"
            data-tab="decrypt"
            role="tabpanel"
            aria-label="Decrypt"
            aria-hidden="true"
          >
            <div class="section-header">
              <h2>Decrypt</h2>
            </div>
            <div class="stepper" id="workflow-decrypt">
              <div class="step-toolbar">
                <button type="button" class="action-btn secondary" data-step-prev disabled>Back</button>
                <div class="step-title">
                  <span class="step-title-position" data-step-position>Step 1 of 3</span>
                  <span class="step-title-name" data-step-name>Load encrypted blob</span>
                </div>
                <button type="button" class="action-btn" data-step-next>Next</button>
              </div>
              <div class="step-panels">
                <section
                  class="step-panel step-panel--active"
                  id="decrypt-step-0"
                  data-step-panel="0"
                  data-step-name="Load encrypted blob"
                  aria-hidden="false"
                >
                  <label>
                    Encrypted blob JSON
                    <textarea
                      id="ciphertext-decrypt"
                      rows="8"
                      placeholder='{"version":1,"kdf":"PBKDF2",...}'
                    ></textarea>
                  </label>
                  <div class="controls">
                    <button id="paste-ciphertext-btn" type="button" class="action-btn secondary">
                      Paste from clipboard
                    </button>
                    <button id="read-nfc-btn" type="button" class="action-btn secondary">
                      Read from NFC
                    </button>
                  </div>
                </section>

                <section
                  class="step-panel"
                  id="decrypt-step-1"
                  data-step-panel="1"
                  data-step-name="Passphrase (if any)"
                  hidden
                  aria-hidden="true"
                >
                  <label>
                    Passphrase
                    <input id="decrypt-passphrase" type="password" autocomplete="current-password" />
                  </label>
                </section>

                <section
                  class="step-panel"
                  id="decrypt-step-2"
                  data-step-panel="2"
                  data-step-name="Plain text"
                  hidden
                  aria-hidden="true"
                >
                  <label>
                    Plain text
                    <textarea
                      id="decrypt-plaintext"
                      rows="6"
                      readonly
                      placeholder="Plaintext will appear here after decrypting."
                    ></textarea>
                  </label>
                </section>
              </div>
            </div>
          </section>
        </div>
      </main>

      <div id="status" role="status" aria-live="polite">Ready.</div>

      <footer>
        <p>Data never leaves your browser. Ensure you wipe downloaded plaintext files after use.</p>
      </footer>
    </div>

    <script type="module">
      const DEFAULT_ITERATIONS = 600_000;
      const MIN_ITERATIONS = 100_000;

      function requireElement(id) {
        const el = document.getElementById(id);
        if (!el) throw new Error(`Missing required element #${id}`);
        return el;
      }

      function initWorkflow(id, workflowOptions = {}) {
        const root = requireElement(id);
        const panels = Array.from(root.querySelectorAll("[data-step-panel]"));
        const toolbar = root.querySelector(".step-toolbar");
        const nextButton = toolbar?.querySelector("[data-step-next]") || null;
        const prevButton = toolbar?.querySelector("[data-step-prev]") || null;
        const positionEl = toolbar?.querySelector("[data-step-position]") || null;
        const nameEl = toolbar?.querySelector("[data-step-name]") || null;

        let current = 0;
        let maxVisited = 0;

        function setStep(index, options = {}) {
          const clamped = Math.max(0, Math.min(index, panels.length - 1));
          if (!options.force && clamped > maxVisited + 1) {
            return;
          }
          if (clamped > maxVisited) {
            maxVisited = clamped;
          }
          current = clamped;
          root.dataset.currentStep = String(current);

          panels.forEach((panel, idx) => {
            const active = idx === current;
            panel.classList.toggle("step-panel--active", active);
            panel.hidden = !active;
            panel.setAttribute("aria-hidden", active ? "false" : "true");
          });

          if (positionEl) {
            positionEl.textContent = `Step ${current + 1} of ${panels.length}`;
          }
          if (nameEl) {
            nameEl.textContent = panels[current]?.dataset.stepName || "";
          }
          if (prevButton) {
            prevButton.disabled = current === 0;
          }
          if (nextButton) {
            const total = panels.length;
            const isLast = current >= total - 1;
            const labelFn = workflowOptions.nextLabel ?? ((stepIndex, totalSteps) => undefined);
            const computedLabel = typeof labelFn === "function" ? labelFn(current, total) : undefined;
            let label = typeof computedLabel === "string" ? computedLabel : "Next";
            nextButton.disabled = isLast;
            if (isLast && typeof computedLabel !== "string") {
              label = "Done";
            }
            nextButton.textContent = label;
          }
        }

        if (nextButton) {
          nextButton.addEventListener("click", () => {
            if (typeof workflowOptions.onNext === "function") {
              const handled = workflowOptions.onNext({
                currentStep: current,
                setStep,
                panels,
                nextButton,
                prevButton,
                root,
              });
              if (handled === true) {
                return;
              }
            }
            setStep(current + 1);
          });
        }

        if (prevButton) {
          prevButton.addEventListener("click", () => {
            setStep(current - 1, { force: true });
          });
        }

        setStep(0, { force: true });

        return {
          setStep,
          get currentStep() {
            return current;
          },
          get maxVisited() {
            return maxVisited;
          },
        };
      }

      window.addEventListener("DOMContentLoaded", () => {
        const elements = {
          tabPanels: requireElement("tab-panels"),
          encryptPassphrase: requireElement("encrypt-passphrase"),
          encryptPassphraseConfirm: requireElement("encrypt-passphrase-confirm"),
          decryptPassphrase: requireElement("decrypt-passphrase"),
          iterations: requireElement("iterations"),
          encryptPlaintext: requireElement("encrypt-plaintext"),
          ciphertextEncrypt: requireElement("ciphertext-encrypt"),
          ciphertextDecrypt: requireElement("ciphertext-decrypt"),
          decryptPlaintext: requireElement("decrypt-plaintext"),
          copyCiphertextBtn: requireElement("copy-ciphertext-btn"),
          pasteCiphertextBtn: requireElement("paste-ciphertext-btn"),
          readNfcBtn: requireElement("read-nfc-btn"),
          writeNfcBtn: requireElement("write-nfc-btn"),
          status: requireElement("status"),
        };

        const workflows = {
          encrypt: initWorkflow("workflow-encrypt", {
            nextLabel: (stepIndex, totalSteps) => {
              if (stepIndex === 2) return "Encrypt";
              if (stepIndex >= totalSteps - 1) return "Done";
              return "Next";
            },
            onNext: ({ currentStep, nextButton }) => {
              if (currentStep === 2) {
                handleEncrypt({ triggerButton: nextButton });
                return true;
              }
              return false;
            },
          }),
          decrypt: initWorkflow("workflow-decrypt", {
            nextLabel: (stepIndex, totalSteps) => {
              if (stepIndex === 1) return "Decrypt";
              if (stepIndex >= totalSteps - 1) return "Done";
              return "Next";
            },
            onNext: ({ currentStep, nextButton }) => {
              if (currentStep === 1) {
                handleDecrypt({ triggerButton: nextButton });
                return true;
              }
              return false;
            },
          }),
        };

        const tabButtons = Array.from(document.querySelectorAll("[data-tab-target]"));
        const tabPanels = Array.from(elements.tabPanels.querySelectorAll(".tab-panel"));
        let activeTab = elements.tabPanels.dataset.activeTab || "encrypt";

        function setStatus(message, tone = "info") {
          elements.status.textContent = message;
          const toneStyles = {
            error: { color: "#fecaca", background: "rgba(248, 113, 113, 0.16)" },
            success: { color: "#bbf7d0", background: "rgba(34, 197, 94, 0.16)" },
            info: { color: "rgba(191, 219, 254, 0.95)", background: "rgba(59, 130, 246, 0.18)" },
          };
          const { color, background } = toneStyles[tone] ?? toneStyles.info;
          elements.status.style.color = color;
          elements.status.style.background = background;
        }

        function toBase64(u8) {
          const CHUNK_SIZE = 0x8000;
          let binary = "";
          for (let i = 0; i < u8.length; i += CHUNK_SIZE) {
            const chunk = u8.subarray(i, i + CHUNK_SIZE);
            binary += String.fromCharCode(...chunk);
          }
          return btoa(binary);
        }

        function fromBase64(str) {
          const binary = atob(str);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        }

        function encodeUtf8(s) {
          return new TextEncoder().encode(s);
        }

        function decodeUtf8(bytes) {
          return new TextDecoder().decode(bytes);
        }

        function dataViewToString(data) {
          if (data instanceof DataView) {
            return new TextDecoder().decode(
              new Uint8Array(data.buffer, data.byteOffset, data.byteLength),
            );
          }
          if (data instanceof ArrayBuffer) {
            return new TextDecoder().decode(new Uint8Array(data));
          }
          if (data instanceof Uint8Array) {
            return new TextDecoder().decode(data);
          }
          if (typeof data === "string") {
            return data;
          }
          return "";
        }

        function parseIterations(value) {
          if (!value) return DEFAULT_ITERATIONS;
          const parsed = Number(value);
          if (!Number.isFinite(parsed) || parsed < MIN_ITERATIONS) {
            throw new Error(`Iterations must be a number ≥ ${MIN_ITERATIONS}.`);
          }
          return Math.floor(parsed);
        }

        async function deriveKey(passphrase, salt, iterations) {
          const baseKey = await crypto.subtle.importKey(
            "raw",
            encodeUtf8(passphrase),
            { name: "PBKDF2" },
            false,
            ["deriveKey"],
          );
          return await crypto.subtle.deriveKey(
            {
              name: "PBKDF2",
              hash: "SHA-256",
              salt,
              iterations,
            },
            baseKey,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"],
          );
        }

        async function encryptPlaintext(plaintext, passphrase, iterations) {
          if (!plaintext.trim()) throw new Error("Plaintext input is empty.");
          const salt = crypto.getRandomValues(new Uint8Array(16));
          const nonce = crypto.getRandomValues(new Uint8Array(12));
          const key = await deriveKey(passphrase, salt, iterations);

          const ciphertext = new Uint8Array(
            await crypto.subtle.encrypt(
              { name: "AES-GCM", iv: nonce },
              key,
              encodeUtf8(plaintext),
            ),
          );

          const blob = {
            version: 1,
            kdf: "PBKDF2",
            hash: "SHA-256",
            iterations,
            salt_b64: toBase64(salt),
            nonce_b64: toBase64(nonce),
            ciphertext_b64: toBase64(ciphertext),
          };

          return JSON.stringify(blob, null, 2);
        }

        async function decryptBlob(blobJson, passphrase) {
          if (!blobJson.trim()) throw new Error("Encrypted blob input is empty.");
          const blob = JSON.parse(blobJson);

          if (blob.kdf !== "PBKDF2" || blob.hash !== "SHA-256") {
            throw new Error("Unsupported KDF parameters.");
          }

          const salt = fromBase64(blob.salt_b64);
          const nonce = fromBase64(blob.nonce_b64);
          const ciphertext = fromBase64(blob.ciphertext_b64);
          const key = await deriveKey(passphrase, salt, blob.iterations);

          const plaintextBytes = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: nonce },
            key,
            ciphertext,
          );
          return decodeUtf8(new Uint8Array(plaintextBytes));
        }

        function setCiphertext(value) {
          const normalized = value ?? "";
          elements.ciphertextEncrypt.value = normalized;
          elements.ciphertextDecrypt.value = normalized;
        }

        function syncCiphertext(source, target) {
          source.addEventListener("input", () => {
            if (target.value !== source.value) {
              target.value = source.value;
            }
          });
        }

        syncCiphertext(elements.ciphertextEncrypt, elements.ciphertextDecrypt);
        syncCiphertext(elements.ciphertextDecrypt, elements.ciphertextEncrypt);

        function getPassphraseForEncrypt() {
          const pw = elements.encryptPassphrase.value;
          const confirm = elements.encryptPassphraseConfirm.value;

          if (!pw && !confirm) {
            return "";
          }
          if (!pw && confirm) {
            throw new Error("Enter a passphrase to match the confirmation.");
          }
          if (pw && !confirm) {
            throw new Error("Confirm the passphrase to continue.");
          }
          if (pw.length < 4) {
            throw new Error("Passphrase must be at least 4 characters.");
          }
          if (pw !== confirm) {
            throw new Error("Passphrases do not match.");
          }
          return pw;
        }

        function getPassphraseForDecrypt() {
          return elements.decryptPassphrase.value;
        }

        function setTab(tabName, options = {}) {
          const target = tabName || activeTab;
          const panel = tabPanels.find((panelEl) => panelEl.dataset.tab === target);
          if (!panel) return;

          activeTab = panel.dataset.tab;
          elements.tabPanels.dataset.activeTab = activeTab;

          tabPanels.forEach((panelEl) => {
            const isActive = panelEl.dataset.tab === activeTab;
            panelEl.classList.toggle("tab-panel--active", isActive);
            panelEl.setAttribute("aria-hidden", isActive ? "false" : "true");
          });

          tabButtons.forEach((button) => {
            const isActive = button.dataset.tabTarget === activeTab;
            button.classList.toggle("tab-btn--active", isActive);
            button.setAttribute("aria-selected", isActive ? "true" : "false");
            button.setAttribute("tabindex", isActive ? "0" : "-1");
            if (isActive && options.focusButton) {
              button.focus();
            }
          });
        }

        tabButtons.forEach((button, index) => {
          button.addEventListener("click", () => {
            setTab(button.dataset.tabTarget || activeTab);
          });
          button.addEventListener("keydown", (event) => {
            if (event.key === "ArrowRight" || event.key === "ArrowLeft") {
              event.preventDefault();
              const direction = event.key === "ArrowRight" ? 1 : -1;
              const nextIndex = (index + direction + tabButtons.length) % tabButtons.length;
              const nextButton = tabButtons[nextIndex];
              setTab(nextButton.dataset.tabTarget || activeTab, { focusButton: true });
            }
          });
        });

        setTab(activeTab);

        async function handleEncrypt(options = {}) {
          const triggerButton = options.triggerButton ?? null;
          const originalLabel = triggerButton?.textContent;
          let shouldRestoreButton = Boolean(triggerButton);
          if (triggerButton) {
            triggerButton.disabled = true;
            if (originalLabel) {
              triggerButton.textContent = "Encrypting…";
            }
          }
          try {
            setStatus("Encrypting…");
            const passphrase = getPassphraseForEncrypt();
            const iterations = parseIterations(elements.iterations.value);
            const plaintext = elements.encryptPlaintext.value;
            const blobJson = await encryptPlaintext(plaintext, passphrase, iterations);
            setCiphertext(blobJson);
            workflows.encrypt.setStep(3, { force: true });
            setStatus("Encryption complete.", "success");
            shouldRestoreButton = false;
          } catch (err) {
            console.error(err);
            setStatus(err instanceof Error ? err.message : String(err), "error");
          } finally {
            if (triggerButton && shouldRestoreButton) {
              triggerButton.disabled = false;
              if (originalLabel) {
                triggerButton.textContent = originalLabel;
              }
            }
          }
        }

        async function handleDecrypt(options = {}) {
          if (options instanceof Event) {
            options.preventDefault?.();
            options = {};
          }
          const triggerButton = options.triggerButton ?? null;
          const originalLabel = triggerButton?.textContent;
          let shouldRestoreButton = Boolean(triggerButton);
          if (triggerButton) {
            triggerButton.disabled = true;
            if (originalLabel) {
              triggerButton.textContent = "Decrypting…";
            }
          }
          try {
            setStatus("Decrypting…");
            const passphrase = getPassphraseForDecrypt();
            const blobJson = elements.ciphertextDecrypt.value;
            const plaintext = await decryptBlob(blobJson, passphrase);
            elements.decryptPlaintext.value = plaintext;
            elements.encryptPlaintext.value = plaintext;
            workflows.decrypt.setStep(2, { force: true });
            setStatus("Decryption complete.", "success");
            shouldRestoreButton = false;
          } catch (err) {
            console.error(err);
            setStatus(err instanceof Error ? err.message : String(err), "error");
          } finally {
            if (triggerButton && shouldRestoreButton) {
              triggerButton.disabled = false;
              if (originalLabel) {
                triggerButton.textContent = originalLabel;
              }
            }
          }
        }

        async function handleWriteNfc() {
          if (!("NDEFReader" in window)) {
            setStatus("Web NFC not supported on this device.", "error");
            return;
          }
          const blobJson = elements.ciphertextEncrypt.value.trim();
          if (!blobJson) {
            setStatus("Encrypt text first before writing to NFC.", "error");
            return;
          }
          try {
            setStatus("Bring an NFC tag close to write…");
            const ndef = new NDEFReader();
            await ndef.write({
              records: [
                {
                  recordType: "mime",
                  mediaType: "application/json",
                  data: blobJson,
                },
              ],
            });
            setStatus("Encrypted blob written to NFC tag.", "success");
          } catch (err) {
            console.error(err);
            setStatus(err instanceof Error ? err.message : "Failed to write to NFC.", "error");
          }
        }

        elements.copyCiphertextBtn.addEventListener("click", async () => {
          const data = elements.ciphertextEncrypt.value.trim();
          if (!data) {
            setStatus("No encrypted data to copy.", "error");
            return;
          }
          try {
            await navigator.clipboard.writeText(data);
            setStatus("Encrypted blob copied to clipboard.", "success");
          } catch (err) {
            console.error(err);
            setStatus("Clipboard write failed. Copy manually.", "error");
          }
        });

        elements.pasteCiphertextBtn.addEventListener("click", async () => {
          try {
            const text = await navigator.clipboard.readText();
            if (!text.trim()) {
              setStatus("Clipboard does not contain any text.", "error");
              return;
            }
            setCiphertext(text.trim());
            setTab("decrypt");
            workflows.decrypt.setStep(1, { force: true });
            setStatus("Encrypted blob pasted from clipboard.", "success");
          } catch (err) {
            console.error(err);
            setStatus("Clipboard read failed. Paste manually instead.", "error");
          }
        });

        async function handleReadNfc() {
          if (!("NDEFReader" in window)) {
            setStatus("Web NFC not supported on this device.", "error");
            return;
          }
          try {
            setStatus("Bring an NFC tag close to read…");
            const ndef = new NDEFReader();
            const readPromise = new Promise((resolve, reject) => {
              const onReading = (event) => {
                try {
                  const records = event.message.records;
                  if (!records.length) {
                    reject(new Error("No records found on tag."));
                    return;
                  }
                  const record = records[0];
                  const payload = dataViewToString(record.data);
                  resolve(payload);
                } catch (err) {
                  reject(err);
                }
              };
              const onError = () => reject(new Error("Failed to read NFC tag."));
              ndef.addEventListener("reading", onReading, { once: true });
              ndef.addEventListener("readingerror", onError, { once: true });
            });
            await ndef.scan();
            const payload = await readPromise;
            if (!payload || typeof payload !== "string") {
              throw new Error("No readable data on tag.");
            }
            setCiphertext(payload);
            setTab("decrypt");
            workflows.decrypt.setStep(1, { force: true });
            setStatus("Encrypted blob loaded from NFC tag.", "success");
          } catch (err) {
            console.error(err);
            setStatus(err instanceof Error ? err.message : "Failed to read from NFC.", "error");
          }
        }

        elements.writeNfcBtn.addEventListener("click", handleWriteNfc);
        elements.readNfcBtn.addEventListener("click", handleReadNfc);

        if (!("NDEFReader" in window)) {
          elements.writeNfcBtn.disabled = true;
          elements.writeNfcBtn.title = "Web NFC is only available on supported Android browsers.";
          elements.readNfcBtn.disabled = true;
          elements.readNfcBtn.title = "Web NFC is only available on supported Android browsers.";
        }

        setStatus("Ready.");
      });
    </script>
  </body>
</html>
