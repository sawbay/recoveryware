<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Recovery Ware</title>
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%232563eb'/%3E%3Cstop offset='100%25' stop-color='%230c4a6e'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='12' fill='url(%23g)'/%3E%3Cpath fill='white' d='M32 18a8 8 0 0 1 8 8v4h2a2 2 0 0 1 2 2v18a2 2 0 0 1-2 2H22a2 2 0 0 1-2-2V32a2 2 0 0 1 2-2h2v-4a8 8 0 0 1 8-8zm0 4a4 4 0 0 0-4 4v4h8v-4a4 4 0 0 0-4-4zm0 12a4 4 0 1 0 0 8 4 4 0 0 0 0-8z'/%3E%3C/svg%3E"
    />
    <style>
      :root {
        font-family:
          "SF Pro Text",
          "SF Pro Display",
          -apple-system,
          BlinkMacSystemFont,
          "Helvetica Neue",
          "Segoe UI",
          sans-serif;
        color: #f9fafb;
        background-color: #090b11;
        line-height: 1.5;
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: clamp(1.5rem, 5vw, 3rem);
        min-height: 100vh;
        background:
          radial-gradient(circle at 20% 20%, rgba(120, 119, 198, 0.18), transparent 60%),
          radial-gradient(circle at 80% 0%, rgba(56, 189, 248, 0.12), transparent 50%),
          radial-gradient(circle at 0% 80%, rgba(192, 132, 252, 0.15), transparent 55%),
          #040509;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        color: inherit;
      }
      .shell {
        width: min(100%, 760px);
        display: grid;
        gap: clamp(1.5rem, 4vw, 2.75rem);
      }
      header {
        text-align: center;
        display: grid;
        gap: 0.5rem;
        color: #f8fafc;
      }
      header h1 {
        margin: 0;
        font-size: clamp(2.4rem, 5vw, 3.1rem);
        letter-spacing: -0.03em;
        color: #e0f2fe;
        text-shadow:
          0 12px 30px rgba(37, 99, 235, 0.3),
          0 0 18px rgba(59, 130, 246, 0.45),
          0 0 30px rgba(168, 85, 247, 0.35);
      }
      header p {
        margin: 0;
        color: rgba(226, 232, 240, 0.72);
        max-width: 48ch;
        justify-self: center;
      }
      main {
        display: grid;
        gap: 1.75rem;
        flex: 1 0 auto;
      }
      .tab-bar {
        display: inline-flex;
        background: rgba(148, 163, 184, 0.12);
        border-radius: 999px;
        padding: 0.35rem;
        gap: 0.35rem;
        justify-self: center;
        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.16);
        backdrop-filter: blur(18px);
      }
      .tab-btn {
        border: none;
        background: transparent;
        color: rgba(226, 232, 240, 0.76);
        font-weight: 600;
        padding: 0.75rem 1.75rem;
        border-radius: 999px;
        cursor: pointer;
        transition: all 0.25s ease;
      }
      .tab-btn:focus-visible {
        outline: 2px solid rgba(148, 163, 184, 0.5);
        outline-offset: 3px;
      }
      .tab-btn:hover:not(.tab-btn--active) {
        background: rgba(148, 163, 184, 0.18);
        color: #f8fafc;
        transform: translateY(-1px);
      }
      .tab-btn--active {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.85), rgba(14, 165, 233, 0.85));
        color: #0a0c12;
        box-shadow:
          0 12px 30px rgba(56, 189, 248, 0.35),
          inset 0 0 0 1px rgba(241, 245, 249, 0.35);
      }
      .tab-panels {
        display: grid;
        gap: 1.75rem;
      }
      .tab-panel {
        display: none !important;
      }
      .tab-panel--active {
        display: grid !important;
      }
      .panel {
        background: rgba(15, 16, 24, 0.72);
        border-radius: 24px;
        padding: clamp(1.5rem, 4vw, 2.3rem);
        box-shadow:
          0 32px 80px rgba(2, 6, 23, 0.7),
          0 4px 20px rgba(15, 23, 42, 0.3),
          inset 0 1px 0 rgba(148, 163, 184, 0.08);
        border: 1px solid rgba(148, 163, 184, 0.18);
        backdrop-filter: blur(24px);
        display: grid;
        gap: 1.1rem;
      }
      @media (min-width: 768px) {
        .panel {
          padding: clamp(2rem, 3vw, 2.6rem);
        }
      }
      .section-header {
        display: grid;
        gap: 0.25rem;
      }
      .section-header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }
      .section-header-actions {
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
      }
      .section-header-row h2 {
        margin: 0;
        flex: 1;
      }
      .section-header h2 {
        margin: 0;
        font-size: 1.6rem;
        letter-spacing: -0.015em;
        color: #f8fafc;
      }
      .section-header p {
        margin: 0;
        color: rgba(226, 232, 240, 0.6);
        font-size: 0.95rem;
        line-height: 1.5;
      }
      .settings-btn {
        border: 1px solid rgba(148, 163, 184, 0.28);
        background: rgba(148, 163, 184, 0.12);
        border-radius: 999px;
        color: rgba(226, 232, 240, 0.9);
        padding: 0.45rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
      }
      .settings-btn svg {
        width: 1.1rem;
        height: 1.1rem;
      }
      .settings-btn:hover,
      .settings-btn:focus-visible {
        background: rgba(148, 163, 184, 0.22);
        border-color: rgba(226, 232, 240, 0.45);
        outline: none;
        transform: translateY(-1px);
      }
      .settings-btn[aria-pressed="true"] {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.9), rgba(14, 165, 233, 0.9));
        color: #0a0c12;
        border-color: rgba(226, 232, 240, 0.5);
        box-shadow:
          0 12px 30px rgba(56, 189, 248, 0.35),
          inset 0 0 0 1px rgba(241, 245, 249, 0.35);
      }
      .best-practices-btn {
        position: relative;
        isolation: isolate;
        border: 1px solid rgba(148, 197, 255, 0.6);
        background: linear-gradient(135deg, rgba(30, 136, 229, 0.85), rgba(96, 165, 250, 0.85));
        border-radius: 999px;
        color: #f8fafc;
        font-weight: 600;
        padding: 0.5rem 1.45rem;
        cursor: pointer;
        transition: transform 0.25s ease, box-shadow 0.3s ease, filter 0.3s ease;
        box-shadow:
          0 10px 24px rgba(37, 99, 235, 0.35),
          inset 0 1px 0 rgba(241, 245, 249, 0.35);
      }
      .best-practices-btn::before {
        content: "";
        position: absolute;
        inset: -6px;
        border-radius: inherit;
        background: radial-gradient(circle at 30% 20%, rgba(125, 211, 252, 0.65), transparent 60%),
          radial-gradient(circle at 75% 80%, rgba(129, 140, 248, 0.75), transparent 65%);
        opacity: 0.8;
        filter: blur(14px);
        z-index: -1;
        transition: opacity 0.3s ease, filter 0.3s ease;
      }
      .best-practices-btn:hover,
      .best-practices-btn:focus-visible {
        outline: none;
        transform: translateY(-2px);
        box-shadow:
          0 18px 36px rgba(37, 99, 235, 0.45),
          inset 0 1px 0 rgba(241, 245, 249, 0.45);
        filter: brightness(1.05);
      }
      .best-practices-btn:hover::before,
      .best-practices-btn:focus-visible::before {
        opacity: 1;
        filter: blur(18px);
      }
      .best-practices-btn:focus-visible {
        box-shadow:
          0 0 0 3px rgba(191, 219, 254, 0.35),
          0 20px 40px rgba(37, 99, 235, 0.45),
          inset 0 1px 0 rgba(241, 245, 249, 0.45);
      }
      .modal-layer {
        position: fixed;
        inset: 0;
        z-index: 1100;
        background: rgba(4, 6, 14, 0.68);
        backdrop-filter: blur(16px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
        pointer-events: none;
      }
      .modal-layer.is-open {
        pointer-events: auto;
      }
      .modal-layer[hidden] {
        display: none !important;
      }
      .best-practices-dialog {
        width: min(560px, 100%);
        max-height: min(72vh, 680px);
        background: rgba(9, 14, 24, 0.94);
        border-radius: 22px;
        border: 1px solid rgba(125, 211, 252, 0.2);
        box-shadow:
          0 28px 60px rgba(2, 6, 23, 0.65),
          0 8px 24px rgba(56, 189, 248, 0.22),
          inset 0 1px 0 rgba(148, 163, 184, 0.12);
        padding: 1.5rem clamp(1.5rem, 4vw, 2rem);
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        overflow: hidden;
        outline: none;
      }
      .best-practices-dialog-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }
      .best-practices-dialog-header h3 {
        margin: 0;
        font-size: 1.2rem;
        color: #f8fafc;
        letter-spacing: -0.01em;
      }
      .best-practices-close {
        border: 1px solid rgba(148, 163, 184, 0.28);
        background: rgba(15, 23, 42, 0.65);
        color: rgba(226, 232, 240, 0.86);
        border-radius: 999px;
        width: 2.1rem;
        height: 2.1rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
      }
      .best-practices-close:hover,
      .best-practices-close:focus-visible {
        background: rgba(30, 41, 59, 0.75);
        border-color: rgba(226, 232, 240, 0.5);
        outline: none;
        transform: translateY(-1px);
      }
      .best-practices-dialog-body {
        overflow-y: auto;
        padding-right: 0.25rem;
        flex: 1 1 auto;
        min-height: 0;
      }
      .settings-layer {
        position: fixed;
        inset: 0;
        z-index: 1000;
        pointer-events: none;
      }
      .settings-layer.is-open {
        pointer-events: auto;
      }
      .settings-layer[hidden] {
        display: none !important;
      }
      .settings-fields[hidden],
      #advanced-summary[hidden],
      #advanced-description[hidden] {
        display: none !important;
      }
      .advanced-settings {
        position: fixed;
        display: grid;
        gap: 0.75rem;
        min-width: 240px;
        max-width: min(320px, 90vw);
        padding: 1rem 1.1rem 1.1rem;
        border-radius: 16px;
        border: 1px solid rgba(59, 130, 246, 0.32);
        background: rgba(8, 11, 20, 0.94);
        box-shadow:
          0 18px 40px rgba(15, 23, 42, 0.45),
          0 0 0 1px rgba(59, 130, 246, 0.08);
        pointer-events: auto;
        --pointer-offset: 50%;
      }
      .advanced-settings--expanded {
        min-height: 230px;
      }
      .advanced-settings::before {
        content: "";
        position: absolute;
        top: -7px;
        left: var(--pointer-offset);
        width: 14px;
        height: 14px;
        transform: translateX(-50%) rotate(45deg);
        background: rgba(8, 11, 20, 0.94);
        border-left: 1px solid rgba(59, 130, 246, 0.32);
        border-top: 1px solid rgba(59, 130, 246, 0.32);
        box-shadow: -3px -3px 12px rgba(15, 23, 42, 0.4);
      }
      .advanced-settings-header {
        display: flex;
        justify-content: space-between;
        gap: 0.6rem;
        align-items: center;
        margin-bottom: 0.8rem;
      }
      .advanced-settings h3 {
        margin: 0;
        font-size: 1rem;
        color: rgba(241, 245, 249, 0.94);
        letter-spacing: -0.01em;
      }
      .advanced-settings .settings-description {
        margin: 0;
        color: rgba(148, 163, 184, 0.85);
        font-size: 0.85rem;
      }
      .advanced-settings .toggle-btn {
        border: 1px solid rgba(99, 102, 241, 0.4);
        background: linear-gradient(135deg, rgba(79, 70, 229, 0.25), rgba(14, 116, 233, 0.2));
        border-radius: 999px;
        color: rgba(248, 250, 252, 0.9);
        font-weight: 600;
        padding: 0.5rem 1.2rem;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
      }
      .advanced-settings .toggle-btn:hover,
      .advanced-settings .toggle-btn:focus-visible {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.38), rgba(14, 165, 233, 0.32));
        border-color: rgba(165, 180, 252, 0.8);
        outline: none;
        transform: translateY(-1px);
      }
      .advanced-settings .toggle-btn[aria-pressed="true"] {
        background: linear-gradient(135deg, rgba(129, 140, 248, 0.95), rgba(56, 189, 248, 0.9));
        color: #0b1120;
        border-color: rgba(226, 232, 240, 0.6);
        box-shadow: 0 12px 26px rgba(99, 102, 241, 0.35);
      }
      .settings-fields {
        display: flex;
        align-items: center;
        gap: 0.65rem;
      }
      .settings-field {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        font-size: 0.78rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: rgba(191, 219, 254, 0.72);
      }
      .settings-field input[type="number"] {
        width: 4.6rem;
        text-align: center;
      }
      .settings-divider {
        color: rgba(148, 163, 184, 0.6);
        font-size: 0.75rem;
      }
      .shamir-section {
        display: grid;
        gap: 1rem;
        background: rgba(15, 23, 42, 0.5);
        border: 1px solid rgba(148, 163, 184, 0.16);
        border-radius: 18px;
        padding: 1.2rem;
      }
      .shamir-section h3 {
        margin: 0;
        font-size: 1.2rem;
        color: #f8fafc;
      }
      .shamir-section .helper-text {
        margin: 0;
      }
      .shamir-share-list,
      .shamir-collected-list {
        display: grid;
        gap: 1rem;
      }
      .shamir-collected-list {
        margin: 0;
        padding: 0;
      }
      .share-card {
        display: grid;
        gap: 0.75rem;
        padding: 1rem;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      .share-card header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-weight: 600;
        color: rgba(226, 232, 240, 0.9);
      }
      .share-card textarea {
        width: 100%;
        min-height: 160px;
        resize: vertical;
      }
      .shamir-collect-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      #shamir-share-input {
        width: 100%;
        min-height: 120px;
      }
      .shamir-collected-list li {
        list-style: none;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.75rem 1rem;
        border-radius: 14px;
        background: rgba(30, 41, 59, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      .shamir-collected-list button {
        margin-left: 1rem;
      }
      label {
        display: grid;
        gap: 0.5rem;
        font-weight: 600;
        color: rgba(226, 232, 240, 0.94);
      }
      input[type="password"],
      input[type="number"],
      textarea {
        width: 100%;
        padding: 0.75rem 1rem;
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        font: inherit;
        background: rgba(15, 23, 42, 0.55);
        color: #f8fafc;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
        transition: border 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }
      input[type="password"]:focus-visible,
      input[type="number"]:focus-visible,
      textarea:focus-visible {
        outline: none;
        border-color: rgba(129, 140, 248, 0.65);
        box-shadow: 0 0 0 4px rgba(129, 140, 248, 0.15);
        background: rgba(20, 28, 48, 0.75);
      }
      textarea {
        resize: vertical;
        min-height: 8rem;
      }
      textarea[readonly] {
        background: rgba(15, 23, 42, 0.4);
        color: rgba(226, 232, 240, 0.65);
      }
      input[type="number"] {
        appearance: textfield;
      }
      input[type="number"]::-webkit-outer-spin-button,
      input[type="number"]::-webkit-inner-spin-button {
        margin: 0;
        appearance: none;
      }
      input::placeholder,
      textarea::placeholder {
        color: rgba(148, 163, 184, 0.6);
      }
      .helper-text {
        margin: 0;
        color: rgba(148, 163, 184, 0.72);
        font-size: 0.9rem;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.85rem;
      }
      .faq-content {
        display: grid;
        gap: 1.25rem;
        color: rgba(226, 232, 240, 0.82);
      }
      .faq-card {
        display: grid;
        gap: 0.5rem;
      }
      .faq-card h3 {
        margin: 0;
        font-size: 1.1rem;
        color: #f8fafc;
        letter-spacing: -0.01em;
      }
      .faq-card p {
        margin: 0;
        line-height: 1.65;
      }
      .faq-card ul {
        margin: 0;
        padding-left: 1.25rem;
        line-height: 1.6;
        color: rgba(226, 232, 240, 0.82);
      }
      .faq-card li + li {
        margin-top: 0.35rem;
      }
      .faq-card a {
        color: #93c5fd;
        text-decoration: none;
      }
      .faq-card a:hover,
      .faq-card a:focus-visible {
        text-decoration: underline;
      }
      .best-practices {
        display: grid;
        gap: 1.25rem;
        color: rgba(226, 232, 240, 0.82);
      }
      .best-practice-card {
        display: grid;
        gap: 0.65rem;
        padding: 1.1rem 1.35rem;
        border-radius: 18px;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(94, 114, 228, 0.2);
        box-shadow: inset 0 1px 0 rgba(148, 163, 184, 0.08);
      }
      .best-practice-card h3 {
        margin: 0;
        font-size: 1.15rem;
        color: #f8fafc;
        letter-spacing: -0.01em;
      }
      .best-practice-card p {
        margin: 0;
        line-height: 1.6;
        color: rgba(226, 232, 240, 0.82);
      }
      .best-practice-card ol {
        margin: 0;
        padding-left: 1.35rem;
        display: grid;
        gap: 0.4rem;
      }
      .best-practice-card strong {
        color: rgba(191, 219, 254, 0.92);
      }
      .action-btn {
        background: linear-gradient(135deg, #6366f1, #0ea5e9);
        color: #0a0c12;
        border: none;
        border-radius: 16px;
        padding: 0.85rem 1.9rem;
        min-height: 3rem;
        font-weight: 600;
        letter-spacing: 0.01em;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.25s ease, filter 0.2s ease;
      }
      .action-btn:hover:not(:disabled),
      .action-btn:focus-visible:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 20px 40px rgba(14, 165, 233, 0.35);
        filter: brightness(1.08);
        outline: none;
      }
      .action-btn:disabled {
        background: rgba(148, 163, 184, 0.22);
        color: rgba(226, 232, 240, 0.4);
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .action-btn.secondary {
        background: rgba(148, 163, 184, 0.18);
        color: rgba(226, 232, 240, 0.9);
        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.25);
      }
      .action-btn.secondary:hover:not(:disabled),
      .action-btn.secondary:focus-visible:not(:disabled) {
        background: rgba(148, 163, 184, 0.28);
        box-shadow: inset 0 0 0 1px rgba(226, 232, 240, 0.22);
      }
      .stepper {
        display: grid;
        gap: 1rem;
      }
      .step-toolbar {
        display: flex;
        align-items: flex-end;
        gap: 1rem;
      }
      .step-toolbar [data-step-prev],
      .step-toolbar [data-step-next] {
        flex-shrink: 0;
      }
      .step-toolbar [data-step-next] {
        margin-left: auto;
      }
      .step-title {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.2rem;
        text-align: center;
      }
      .step-title-position {
        font-size: 0.85rem;
        color: rgba(203, 213, 225, 0.6);
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .step-title-name {
        font-weight: 600;
        font-size: 1.05rem;
        color: #f8fafc;
      }
      @media (min-width: 640px) {
        .step-title {
          text-align: left;
          align-items: flex-start;
        }
      }
      .step-panels {
        position: relative;
      }
      .step-panel {
        display: none;
        gap: 1rem;
        align-content: start;
      }
      .step-panel--active {
        display: grid;
      }
      #status {
        background: rgba(59, 130, 246, 0.18);
        border-radius: 18px;
        padding: 1rem 1.4rem;
        font-weight: 600;
        color: rgba(191, 219, 254, 0.95);
        text-align: center;
        backdrop-filter: blur(24px);
        box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.35);
        margin: 1rem 0 0;
      }
      #nfc-dialog-layer {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
        background: rgba(15, 23, 42, 0.75);
        backdrop-filter: blur(16px);
        z-index: 2000;
      }
      #nfc-dialog-layer[hidden] {
        display: none;
      }
      #nfc-dialog {
        background: rgba(15, 23, 42, 0.95);
        border-radius: 20px;
        padding: 1.75rem;
        width: min(26rem, 100%);
        display: grid;
        gap: 1.25rem;
        box-shadow: 0 28px 60px rgba(15, 23, 42, 0.45);
        border: 1px solid rgba(148, 163, 184, 0.2);
        color: #e2e8f0;
        outline: none;
      }
      .nfc-dialog-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }
      #nfc-dialog-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #f8fafc;
        margin: 0;
      }
      .nfc-dialog-close {
        background: transparent;
        border: none;
        color: rgba(226, 232, 240, 0.8);
        font-size: 1.6rem;
        line-height: 1;
        cursor: pointer;
        padding: 0.2rem;
      }
      .nfc-dialog-close:hover,
      .nfc-dialog-close:focus-visible {
        color: #f8fafc;
      }
      .nfc-dialog-close[hidden] {
        display: none;
      }
      .nfc-dialog-body {
        display: flex;
        align-items: flex-start;
        gap: 1rem;
      }
      .nfc-dialog-spinner {
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 50%;
        border: 3px solid rgba(148, 163, 184, 0.25);
        border-top-color: rgba(59, 130, 246, 0.75);
        animation: nfc-spin 1s linear infinite;
        display: none;
        margin-top: 0.15rem;
      }
      #nfc-dialog[data-busy="true"] .nfc-dialog-spinner {
        display: inline-block;
      }
      #nfc-dialog-message {
        margin: 0;
        font-size: 1rem;
        line-height: 1.55;
      }
      .nfc-dialog-footer {
        display: flex;
        justify-content: flex-end;
      }
      #nfc-dialog-dismiss[hidden] {
        display: none;
      }
      #nfc-dialog[data-tone="success"] {
        border-color: rgba(34, 197, 94, 0.5);
        box-shadow: 0 24px 48px rgba(34, 197, 94, 0.2);
      }
      #nfc-dialog[data-tone="error"] {
        border-color: rgba(248, 113, 113, 0.5);
        box-shadow: 0 24px 48px rgba(248, 113, 113, 0.2);
      }
      @keyframes nfc-spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      footer {
        text-align: center;
        color: rgba(148, 163, 184, 0.65);
        margin-bottom: 1rem;
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header>
        <h1>Recovery Ware</h1>
        <p>Encrypt your seed phrase and save securely, not on paper.</p>
      </header>

      <div
        id="nfc-dialog-layer"
        hidden
      >
        <div
          id="nfc-dialog"
          class="nfc-dialog"
          role="dialog"
          aria-modal="true"
          aria-labelledby="nfc-dialog-title"
          aria-describedby="nfc-dialog-message"
          tabindex="-1"
          data-tone="info"
          data-busy="false"
        >
          <div class="nfc-dialog-header">
            <h3 id="nfc-dialog-title">NFC operation</h3>
            <button type="button" id="nfc-dialog-close" class="nfc-dialog-close" aria-label="Close NFC dialog">
              &times;
            </button>
          </div>
          <div class="nfc-dialog-body">
            <div id="nfc-dialog-spinner" class="nfc-dialog-spinner" aria-hidden="true"></div>
            <p id="nfc-dialog-message"></p>
          </div>
          <div class="nfc-dialog-footer">
            <button type="button" id="nfc-dialog-dismiss" class="action-btn secondary">Close</button>
          </div>
        </div>
      </div>

      <main>
        <div class="tab-bar" role="tablist" aria-label="App sections">
          <button
            type="button"
            class="tab-btn tab-btn--active"
            data-tab-target="encrypt"
            role="tab"
            aria-controls="tab-encrypt"
            aria-selected="true"
            tabindex="0"
          >
            Encrypt
          </button>
          <button
            type="button"
            class="tab-btn"
            data-tab-target="decrypt"
            role="tab"
            aria-controls="tab-decrypt"
            aria-selected="false"
            tabindex="-1"
          >
            Decrypt
          </button>
          <button
            type="button"
            class="tab-btn"
            data-tab-target="faq"
            role="tab"
            aria-controls="tab-faq"
            aria-selected="false"
            tabindex="-1"
          >
            FAQ
          </button>
        </div>
        <div id="advanced-settings-layer" class="settings-layer" hidden>
          <div
            id="advanced-settings"
            class="advanced-settings"
            role="dialog"
            aria-modal="true"
            aria-labelledby="advanced-settings-title"
            tabindex="-1"
          >
            <div class="advanced-settings-header">
              <h3 id="advanced-settings-title">Advanced mode</h3>
              <button type="button" id="advanced-enable" class="toggle-btn" aria-pressed="false">
                OFF
              </button>
            </div>
            <p id="advanced-description" class="settings-description">Split ciphertext into coordinated recovery keys.</p>
            <p id="advanced-summary" class="settings-description" hidden></p>
            <div id="advanced-settings-fields" class="settings-fields" role="group" aria-label="Shamir key split configuration" hidden>
              <label class="settings-field">
                <span>Threshold</span>
                <input id="advanced-threshold" type="number" min="2" max="10" value="2" />
              </label>
              <span class="settings-divider">of</span>
              <label class="settings-field">
                <span>Total keys</span>
                <input id="advanced-total" type="number" min="2" max="10" value="3" />
              </label>
            </div>
          </div>
        </div>
        <div
          id="best-practices-layer"
          class="modal-layer"
          hidden
        >
          <div
            id="best-practices-dialog"
            class="best-practices-dialog"
            role="dialog"
            aria-modal="true"
            aria-labelledby="best-practices-title"
            tabindex="-1"
          >
            <div class="best-practices-dialog-header">
              <h3 id="best-practices-title">Best Practices</h3>
              <button
                type="button"
                id="best-practices-close"
                class="best-practices-close"
                aria-label="Close best practices"
              >
                &times;
              </button>
            </div>
            <div class="best-practices-dialog-body">
              <div class="best-practices">
                <article class="best-practice-card">
                  <h3>Medium Protection</h3>
                  <p>Protect seed phrases with a given passphrase.</p>
                  <ol>
                    <li>Generate a <strong>secure random password</strong> (16+ characters) using a trusted password manager or hardware token.</li>
                    <li>Encrypt the secret, and <strong>write the ciphertext to an NFC tag</strong>.</li>
                    <li>Clone multiple NFC tags so you have primary and backup copies; label them physically without revealing what they protect.</li>
                    <li>Test a clone on a clean device before storing them away to ensure the NFC export works.</li>
                  </ol>
                  <p class="helper-text">Keep NFC tags in separate, water-resistant sleeves and audit them every 6–12 months.</p>
                </article>
                <article class="best-practice-card">
                  <h3>High Protection</h3>
                  <p>Protect seed phrases that cannot afford a single point of failure.</p>
                  <ol>
                    <li>Generate a <strong>random password</strong> dedicated to the seed phrase; record it temporarily in a secure offline note.</li>
                    <li>Encrypt the seed phrase with that password and <strong>clone multiple copies of the encrypted seed</strong>—JSON, NFC, or both.</li>
                    <li>Enable advanced mode, set it to <strong>2 of 3 keys</strong>, and encrypt the random password to create three recovery keys.</li>
                    <li>Store the recovery keys in separate locations: one at home, one at the office, and one with your spouse or wife.</li>
                    <li>Document the reconstruction steps: retrieve any two keys, rebuild the password, then decrypt any stored copy of the seed phrase.</li>
                  </ol>
                  <p class="helper-text">Never keep two keys together; rehearse the reconstruction annually to confirm every location remains in sync.</p>
                </article>
              </div>
            </div>
          </div>
        </div>
        <div class="tab-panels" id="tab-panels" data-active-tab="encrypt">
          <section
            class="panel tab-panel tab-panel--active"
            id="tab-encrypt"
            data-tab="encrypt"
            role="tabpanel"
            aria-label="Encrypt"
            aria-hidden="false"
          >
            <div class="section-header">
              <div class="section-header-row">
                <h2>Encrypt</h2>
                <div class="section-header-actions">
                  <button
                    type="button"
                    class="best-practices-btn"
                    data-best-practices-trigger
                    aria-haspopup="dialog"
                  >
                    Best Practices
                  </button>
                  <button
                    type="button"
                    class="settings-btn"
                    data-settings-trigger
                    aria-expanded="false"
                    aria-controls="advanced-settings"
                    aria-pressed="false"
                    title="Toggle advanced Shamir secret sharing settings"
                  >
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                      <path
                        d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm8.5-3a6.5 6.5 0 0 1-.06.86l2.11 1.65a1 1 0 0 1 .24 1.3l-2 3.46a1 1 0 0 1-1.21.45l-2.49-1a6.52 6.52 0 0 1-1.49.86l-.38 2.65a1 1 0 0 1-1 .86h-4a1 1 0 0 1-1-.86l-.38-2.65a6.52 6.52 0 0 1-1.49-.86l-2.49 1a1 1 0 0 1-1.21-.45l-2-3.46a1 1 0 0 1 .24-1.3l2.11-1.65A6.5 6.5 0 0 1 3.5 12a6.5 6.5 0 0 1 .06-.86L1.45 9.49a1 1 0 0 1-.24-1.3l2-3.46a1 1 0 0 1 1.21-.45l2.49 1a6.52 6.52 0 0 1 1.49-.86l.38-2.65A1 1 0 0 1 10 1h4a1 1 0 0 1 1 .86l.38 2.65a6.52 6.52 0 0 1 1.49.86l2.49-1a1 1 0 0 1 1.21.45l2 3.46a1 1 0 0 1-.24 1.3l-2.11 1.65c.04.28.07.57.07.87z"
                      />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
            <div id="status" role="status" aria-live="polite">Ready.</div>
            <div class="stepper" id="workflow-encrypt">
              <div class="step-toolbar">
                <button type="button" class="action-btn secondary" data-step-prev disabled>Back</button>
                <div class="step-title">
                  <span class="step-title-position" data-step-position>Step 1 of 4</span>
                  <span class="step-title-name" data-step-name>Enter plain text</span>
                </div>
                <button type="button" class="action-btn" data-step-next>Next</button>
              </div>
              <div class="step-panels">
                <section
                  class="step-panel step-panel--active"
                  id="encrypt-step-0"
                  data-step-panel="0"
                  data-step-name="Enter plain text"
                  aria-hidden="false"
                >
                  <label>
                    Plaintext
                    <textarea
                      id="encrypt-plaintext"
                      rows="6"
                      placeholder="Enter plaintext seed or other secret..."
                    ></textarea>
                  </label>
                </section>

                <section
                  class="step-panel"
                  id="encrypt-step-1"
                  data-step-panel="1"
                  data-step-name="Passphrase (optional)"
                  hidden
                  aria-hidden="true"
                >
                  <p class="helper-text">Add a passphrase for stronger protection or leave blank to rely on device security.</p>
                  <label>
                    Passphrase
                    <input id="encrypt-passphrase" type="password" autocomplete="new-password" />
                  </label>
                  <label>
                    Confirm passphrase
                    <input id="encrypt-passphrase-confirm" type="password" autocomplete="new-password" />
                  </label>
                </section>

                <section
                  class="step-panel"
                  id="encrypt-step-2"
                  data-step-panel="2"
                  data-step-name="Iterations"
                  hidden
                  aria-hidden="true"
                >
                  <label>
                    PBKDF2 iterations
                    <input
                      id="iterations"
                      type="number"
                      min="100000"
                      value="600000"
                      inputmode="numeric"
                    />
                  </label>
                  <p class="helper-text">Defaults to 600,000 iterations for a balanced KDF. Higher counts strengthen brute-force resistance at the cost of speed.</p>
                </section>

                <section
                  class="step-panel"
                  id="encrypt-step-3"
                  data-step-panel="3"
                  data-step-name="Copy or write to NFC"
                  hidden
                  aria-hidden="true"
                >
                  <label>
                    Encrypted blob JSON
                    <textarea
                      id="ciphertext-encrypt"
                      rows="8"
                      placeholder='{"version":1,"kdf":"PBKDF2",...}'
                    ></textarea>
                  </label>
                  <div class="controls">
                    <button id="copy-ciphertext-btn" type="button" class="action-btn secondary">
                      Copy
                    </button>
                    <button id="download-ciphertext-btn" type="button" class="action-btn secondary">
                      Download
                    </button>
                    <button id="write-nfc-btn" type="button" class="action-btn secondary">
                      Write to NFC
                    </button>
                  </div>
                </section>

                <section
                  class="step-panel"
                  id="encrypt-step-4"
                  data-step-panel="4"
                  data-step-name="Shamir keys"
                  hidden
                  aria-hidden="true"
                  data-step-skip
                >
                  <p id="shamir-step-message" class="helper-text">
                    Enable advanced mode to split the ciphertext into multiple recovery keys.
                  </p>
                  <div id="shamir-encrypt-section" class="shamir-section" hidden>
                    <h3>Shamir keys</h3>
                    <p class="helper-text">
                      Advanced mode splits the encrypted blob into multiple keys. Store each key securely in different places.
                    </p>
                    <div id="shamir-share-list" class="shamir-share-list"></div>
                  </div>
                </section>
              </div>
            </div>
          </section>

          <section
            class="panel tab-panel"
            id="tab-decrypt"
            data-tab="decrypt"
            role="tabpanel"
            aria-label="Decrypt"
            aria-hidden="true"
          >
            <div class="section-header">
              <div class="section-header-row">
                <h2>Decrypt</h2>
                <div class="section-header-actions">
                  <button
                    type="button"
                    class="best-practices-btn"
                    data-best-practices-trigger
                    aria-haspopup="dialog"
                  >
                    Best Practices
                  </button>
                  <button
                    type="button"
                    class="settings-btn"
                    data-settings-trigger
                    aria-expanded="false"
                    aria-controls="advanced-settings"
                    aria-pressed="false"
                    title="Toggle advanced Shamir secret sharing settings"
                  >
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                      <path
                        d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm8.5-3a6.5 6.5 0 0 1-.06.86l2.11 1.65a1 1 0 0 1 .24 1.3l-2 3.46a1 1 0 0 1-1.21.45l-2.49-1a6.52 6.52 0 0 1-1.49.86l-.38 2.65a1 1 0 0 1-1 .86h-4a1 1 0 0 1-1-.86l-.38-2.65a6.52 6.52 0 0 1-1.49-.86l-2.49 1a1 1 0 0 1-1.21-.45l-2-3.46a1 1 0 0 1 .24-1.3l2.11-1.65A6.5 6.5 0 0 1 3.5 12a6.5 6.5 0 0 1 .06-.86L1.45 9.49a1 1 0 0 1-.24-1.3l2-3.46a1 1 0 0 1 1.21-.45l2.49 1a6.52 6.52 0 0 1 1.49-.86l.38-2.65A1 1 0 0 1 10 1h4a1 1 0 0 1 1 .86l.38 2.65a6.52 6.52 0 0 1 1.49.86l2.49-1a1 1 0 0 1 1.21.45l2 3.46a1 1 0 0 1-.24 1.3l-2.11 1.65c.04.28.07.57.07.87z"
                      />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
            <div class="stepper" id="workflow-decrypt">
              <div class="step-toolbar">
                <button type="button" class="action-btn secondary" data-step-prev disabled>Back</button>
                <div class="step-title">
                  <span class="step-title-position" data-step-position>Step 1 of 3</span>
                  <span class="step-title-name" data-step-name>Load encrypted blob</span>
                </div>
                <button type="button" class="action-btn" data-step-next>Next</button>
              </div>
              <div class="step-panels">
                <section
                  class="step-panel"
                  id="decrypt-step-0"
                  data-step-panel="0"
                  data-step-name="Collect Shamir keys"
                  hidden
                  aria-hidden="true"
                  data-step-skip
                >
                  <div id="shamir-decrypt-section" class="shamir-section" hidden>
                    <h3>Collect Shamir keys</h3>
                    <p id="shamir-decrypt-helper" class="helper-text">
                      Import any K of N keys to rebuild the encrypted blob automatically.
                    </p>
                    <div class="shamir-collect-controls">
                      <button id="shamir-upload-btn" type="button" class="action-btn secondary">
                        Upload key files
                      </button>
                      <input id="shamir-upload-input" type="file" accept="application/json,.json" multiple hidden />
                      <button id="shamir-read-share-nfc-btn" type="button" class="action-btn secondary">
                        Read key from NFC
                      </button>
                    </div>
                    <label>
                      Paste key JSON
                      <textarea
                        id="shamir-share-input"
                        placeholder='{"version":1,"scheme":"shamir",...}'
                      ></textarea>
                    </label>
                    <div class="controls">
                      <button id="shamir-add-share-btn" type="button" class="action-btn secondary">
                        Add pasted key
                      </button>
                      <button id="shamir-clear-shares-btn" type="button" class="action-btn secondary">
                        Clear keys
                      </button>
                    </div>
                    <ul id="shamir-collected-shares" class="shamir-collected-list"></ul>
                    <p id="shamir-shares-needed" class="helper-text"></p>
                  </div>
                </section>

                <section
                  class="step-panel step-panel--active"
                  id="decrypt-step-1"
                  data-step-panel="1"
                  data-step-name="Load encrypted blob"
                  aria-hidden="false"
                >
                  <label>
                    Encrypted blob JSON
                    <textarea
                      id="ciphertext-decrypt"
                      rows="8"
                      placeholder='{"version":1,"kdf":"PBKDF2",...}'
                    ></textarea>
                  </label>
                  <div class="controls">
                    <button id="paste-ciphertext-btn" type="button" class="action-btn secondary">Paste</button>
                    <button id="read-nfc-btn" type="button" class="action-btn secondary">
                      Read from NFC
                    </button>
                  </div>
                </section>

                <section
                  class="step-panel"
                  id="decrypt-step-2"
                  data-step-panel="2"
                  data-step-name="Passphrase (if any)"
                  hidden
                  aria-hidden="true"
                >
                  <label>
                    Passphrase
                    <input id="decrypt-passphrase" type="password" autocomplete="current-password" />
                  </label>
                </section>

                <section
                  class="step-panel"
                  id="decrypt-step-3"
                  data-step-panel="3"
                  data-step-name="Plain text"
                  hidden
                  aria-hidden="true"
                >
                  <label>
                    Plain text
                    <textarea
                      id="decrypt-plaintext"
                      rows="6"
                      readonly
                      placeholder="Plaintext will appear here after decrypting."
                    ></textarea>
                  </label>
                </section>
              </div>
            </div>
          </section>

          <section
            class="panel tab-panel"
            id="tab-faq"
            data-tab="faq"
            role="tabpanel"
            aria-label="FAQ"
            aria-hidden="true"
          >
            <div class="section-header">
              <h2>FAQ</h2>
            </div>
            <div class="faq-content">
              <article class="faq-card">
                <h3>What's it for?</h3>
                <p>Encrypt sensitive text—recovery codes, seed phrases, anything private—and save the ciphertext as JSON or onto an NFC tag.</p>
              </article>
              <article class="faq-card">
                <h3>How do I run it safely?</h3>
                <p>Open in a private window, enable airplane mode, finish your task, copy the result, and close the tab.</p>
              </article>
              <article class="faq-card">
                <h3>Do you keep my data?</h3>
                <p>No. Everything stays in browser memory—no network calls or local storage.</p>
              </article>
              <article class="faq-card">
                <h3>Can I audit it?</h3>
                <p>Yes. Use “View Source” or dev tools to inspect this single HTML file; what you see is all that runs.</p>
              </article>
              <article class="faq-card">
                <h3>How do I write to NFC?</h3>
                <p>Android: Web NFC in Chrome/Edge. iPhone: copy the JSON into <a href="https://apps.apple.com/en/app/nfc-tools/id1252962749" target="_blank" rel="noreferrer">NFC Tools</a>, enable airplane mode, write the tag, then delete the app to clear cached data.</p>
              </article>
            </div>
          </section>
        </div>
      </main>

      <footer></footer>
    </div>

    <script type="module">
      const DEFAULT_ITERATIONS = 600_000;
      const MIN_ITERATIONS = 100_000;
      const SHAMIR_DEFAULT_THRESHOLD = 2;
      const SHAMIR_DEFAULT_TOTAL = 3;
      const SHAMIR_MAX_SHARES = 10;

      const GF256 = (() => {
        const POLY = 0x11b;
        const GENERATOR = 0x03;
        function multiplyBase(a, b) {
          let result = 0;
          let left = a;
          let right = b;
          while (right > 0) {
            if (right & 1) {
              result ^= left;
            }
            right >>= 1;
            left <<= 1;
            if (left & 0x100) {
              left ^= POLY;
            }
          }
          return result;
        }
        const exp = new Uint8Array(512);
        const log = new Uint8Array(256);
        let x = 1;
        for (let i = 0; i < 255; i++) {
          exp[i] = x;
          log[x] = i;
          x = multiplyBase(x, GENERATOR);
        }
        for (let i = 255; i < 512; i++) {
          exp[i] = exp[i - 255];
        }
        log[0] = 0;
        function add(a, b) {
          return a ^ b;
        }
        function mul(a, b) {
          if (a === 0 || b === 0) return 0;
          return exp[log[a] + log[b]];
        }
        function inv(a) {
          if (a === 0) {
            throw new Error("Cannot invert zero in GF(256).");
          }
          return exp[255 - log[a]];
        }
        function div(a, b) {
          if (b === 0) {
            throw new Error("Cannot divide by zero in GF(256).");
          }
          if (a === 0) return 0;
          let index = log[a] - log[b];
          if (index < 0) {
            index += 255;
          }
          return exp[index];
        }
        return { add, mul, inv, div };
      })();

      function evaluatePolynomial(coeffs, x) {
        if (!coeffs.length) {
          return 0;
        }
        let result = coeffs[coeffs.length - 1];
        for (let i = coeffs.length - 2; i >= 0; i--) {
          result = GF256.mul(result, x);
          result = GF256.add(result, coeffs[i]);
        }
        return result;
      }

      function shamirSplit(secretBytes, threshold, total) {
        if (!(secretBytes instanceof Uint8Array)) {
          throw new Error("Secret must be a Uint8Array.");
        }
        if (!Number.isInteger(threshold) || !Number.isInteger(total)) {
          throw new Error("Threshold and total must be integers.");
        }
        if (threshold < 2) {
          throw new Error("Threshold must be at least 2.");
        }
        if (total < threshold) {
          throw new Error("Total number of keys must be ≥ threshold.");
        }
        if (total > 255) {
          throw new Error("Total number of keys cannot exceed 255.");
        }
        const shares = Array.from({ length: total }, (_, idx) => ({
          x: idx + 1,
          y: new Uint8Array(secretBytes.length),
        }));
        if (secretBytes.length === 0) {
          return shares.map((share) => ({ x: share.x, y: new Uint8Array(0) }));
        }
        const coeffBuffer = new Uint8Array(Math.max(1, threshold - 1));
        for (let byteIndex = 0; byteIndex < secretBytes.length; byteIndex++) {
          if (threshold > 1) {
            crypto.getRandomValues(coeffBuffer);
          }
          const coeffs = new Uint8Array(threshold);
          coeffs[0] = secretBytes[byteIndex];
          for (let c = 1; c < threshold; c++) {
            coeffs[c] = coeffBuffer[c - 1];
          }
          for (const share of shares) {
            share.y[byteIndex] = evaluatePolynomial(coeffs, share.x);
          }
        }
        return shares;
      }

      function shamirCombine(shares) {
        if (!Array.isArray(shares) || shares.length === 0) {
          throw new Error("Provide at least one share.");
        }
        const shareLength = shares[0].y.length;
        const uniqueX = new Set();
        for (const share of shares) {
          if (!share || typeof share.x !== "number" || !(share.y instanceof Uint8Array)) {
            throw new Error("Share is missing required fields.");
          }
          if (share.y.length !== shareLength) {
            throw new Error("Share lengths do not match.");
          }
          if (share.x <= 0 || share.x > 255) {
            throw new Error("Share x values must be within 1-255.");
          }
          if (uniqueX.has(share.x)) {
            throw new Error("Duplicate share detected.");
          }
          uniqueX.add(share.x);
        }
        const secret = new Uint8Array(shareLength);
        for (let byteIndex = 0; byteIndex < shareLength; byteIndex++) {
          let accum = 0;
          for (let i = 0; i < shares.length; i++) {
            const shareI = shares[i];
            let numerator = 1;
            let denominator = 1;
            for (let j = 0; j < shares.length; j++) {
              if (i === j) continue;
              const shareJ = shares[j];
              numerator = GF256.mul(numerator, shareJ.x);
              denominator = GF256.mul(denominator, GF256.add(shareJ.x, shareI.x));
            }
            const factor = GF256.mul(numerator, GF256.inv(denominator));
            const term = GF256.mul(shareI.y[byteIndex], factor);
            accum = GF256.add(accum, term);
          }
          secret[byteIndex] = accum;
        }
        return secret;
      }

      function requireElement(id) {
        const el = document.getElementById(id);
        if (!el) throw new Error(`Missing required element #${id}`);
        return el;
      }

      function initWorkflow(id, workflowOptions = {}) {
        const root = requireElement(id);
        const panels = Array.from(root.querySelectorAll("[data-step-panel]"));
        const toolbar = root.querySelector(".step-toolbar");
        const nextButton = toolbar?.querySelector("[data-step-next]") || null;
        const prevButton = toolbar?.querySelector("[data-step-prev]") || null;
        const positionEl = toolbar?.querySelector("[data-step-position]") || null;
        const nameEl = toolbar?.querySelector("[data-step-name]") || null;

        let current = 0;
        let maxVisitedVisible = 0;

        const isSkipped = (panel) => panel.hasAttribute("data-step-skip");
        const clampIndex = (value) => Math.max(0, Math.min(value, panels.length - 1));
        const getVisiblePanels = () => panels.filter((panel) => !isSkipped(panel));

        const findForward = (start) => {
          for (let i = clampIndex(start); i < panels.length; i++) {
            if (!isSkipped(panels[i])) return i;
          }
          return null;
        };

        const findBackward = (start) => {
          for (let i = clampIndex(start); i >= 0; i--) {
            if (!isSkipped(panels[i])) return i;
          }
          return null;
        };

        function setStep(index, options = {}) {
          const direction = index === current ? 0 : index > current ? 1 : -1;
          let resolved;
          if (direction > 0) {
            resolved = findForward(index);
          } else if (direction < 0) {
            resolved = findBackward(index);
          } else {
            const clamped = clampIndex(index);
            if (!isSkipped(panels[clamped])) {
              resolved = clamped;
            } else {
              resolved = findForward(clamped);
              if (resolved === null) {
                resolved = findBackward(clamped);
              }
            }
          }
          if (resolved === null) {
            return;
          }

          const visiblePanels = getVisiblePanels();
          const visibleIndex = visiblePanels.indexOf(panels[resolved]);
          if (visibleIndex === -1) {
            return;
          }

          if (!options.force && visibleIndex > maxVisitedVisible + 1) {
            return;
          }

          if (visibleIndex > maxVisitedVisible) {
            maxVisitedVisible = visibleIndex;
          }

          current = resolved;
          root.dataset.currentStep = String(current);

          panels.forEach((panel, idx) => {
            const active = idx === current && !isSkipped(panel);
            panel.classList.toggle("step-panel--active", active);
            panel.hidden = !active || isSkipped(panel);
            panel.setAttribute("aria-hidden", active ? "false" : "true");
          });

          if (positionEl) {
            positionEl.textContent = `Step ${visibleIndex + 1} of ${visiblePanels.length}`;
          }
          if (nameEl) {
            nameEl.textContent = panels[current]?.dataset.stepName || "";
          }
          if (prevButton) {
            prevButton.disabled = visibleIndex <= 0;
          }
          if (nextButton) {
            const isLast = visibleIndex >= visiblePanels.length - 1;
            const labelFn = workflowOptions.nextLabel ?? ((stepIndex, totalSteps) => undefined);
            const computedLabel =
              typeof labelFn === "function" ? labelFn(visibleIndex, visiblePanels.length) : undefined;
            let label = typeof computedLabel === "string" ? computedLabel : "Next";
            nextButton.disabled = isLast;
            if (isLast && typeof computedLabel !== "string") {
              label = "Done";
            }
            nextButton.textContent = label;
          }
        }

        if (nextButton) {
          nextButton.addEventListener("click", () => {
            if (typeof workflowOptions.onNext === "function") {
              const handled = workflowOptions.onNext({
                currentStep: current,
                setStep,
                panels,
                nextButton,
                prevButton,
                root,
              });
              if (handled === true) {
                return;
              }
            }
            setStep(current + 1);
          });
        }

        if (prevButton) {
          prevButton.addEventListener("click", () => {
            setStep(current - 1, { force: true });
          });
        }

        setStep(0, { force: true });

        return {
          setStep,
          get currentStep() {
            return current;
          },
          get maxVisited() {
            return maxVisitedVisible;
          },
        };
      }

      window.addEventListener("DOMContentLoaded", () => {
        const elements = {
          tabPanels: requireElement("tab-panels"),
          advancedSettingsLayer: requireElement("advanced-settings-layer"),
          advancedSettings: requireElement("advanced-settings"),
          bestPracticesLayer: requireElement("best-practices-layer"),
          bestPracticesDialog: requireElement("best-practices-dialog"),
          bestPracticesClose: requireElement("best-practices-close"),
          advancedToggle: requireElement("advanced-enable"),
          advancedSettingsFields: requireElement("advanced-settings-fields"),
          advancedThreshold: requireElement("advanced-threshold"),
          advancedTotal: requireElement("advanced-total"),
          advancedDescription: requireElement("advanced-description"),
          advancedSummary: requireElement("advanced-summary"),
          encryptPassphrase: requireElement("encrypt-passphrase"),
          encryptPassphraseConfirm: requireElement("encrypt-passphrase-confirm"),
          decryptPassphrase: requireElement("decrypt-passphrase"),
          iterations: requireElement("iterations"),
          encryptPlaintext: requireElement("encrypt-plaintext"),
          ciphertextEncrypt: requireElement("ciphertext-encrypt"),
          ciphertextDecrypt: requireElement("ciphertext-decrypt"),
          decryptPlaintext: requireElement("decrypt-plaintext"),
          copyCiphertextBtn: requireElement("copy-ciphertext-btn"),
          downloadCiphertextBtn: requireElement("download-ciphertext-btn"),
          pasteCiphertextBtn: requireElement("paste-ciphertext-btn"),
          readNfcBtn: requireElement("read-nfc-btn"),
          writeNfcBtn: requireElement("write-nfc-btn"),
          shamirStepPanel: requireElement("encrypt-step-4"),
          shamirStepMessage: requireElement("shamir-step-message"),
          shamirEncryptSection: requireElement("shamir-encrypt-section"),
          shamirShareList: requireElement("shamir-share-list"),
          shamirDecryptStep: requireElement("decrypt-step-0"),
          shamirDecryptSection: requireElement("shamir-decrypt-section"),
          shamirShareInput: requireElement("shamir-share-input"),
          shamirAddShareBtn: requireElement("shamir-add-share-btn"),
          shamirClearSharesBtn: requireElement("shamir-clear-shares-btn"),
          shamirCollectedShares: requireElement("shamir-collected-shares"),
          shamirSharesNeeded: requireElement("shamir-shares-needed"),
          shamirUploadBtn: requireElement("shamir-upload-btn"),
          shamirUploadInput: requireElement("shamir-upload-input"),
          shamirReadShareNfcBtn: requireElement("shamir-read-share-nfc-btn"),
          shamirDecryptHelper: requireElement("shamir-decrypt-helper"),
          status: requireElement("status"),
          nfcDialogLayer: requireElement("nfc-dialog-layer"),
          nfcDialog: requireElement("nfc-dialog"),
          nfcDialogTitle: requireElement("nfc-dialog-title"),
          nfcDialogMessage: requireElement("nfc-dialog-message"),
          nfcDialogClose: requireElement("nfc-dialog-close"),
          nfcDialogDismiss: requireElement("nfc-dialog-dismiss"),
          nfcDialogSpinner: requireElement("nfc-dialog-spinner"),
        };

        const advancedState = {
          enabled: false,
          threshold: SHAMIR_DEFAULT_THRESHOLD,
          total: SHAMIR_DEFAULT_TOTAL,
          lastShares: null,
          decrypt: {
            shares: [],
            meta: null,
            combined: false,
          },
        };

        const hasNfc = "NDEFReader" in window;
        const userAgent = navigator.userAgent ?? "";
        const isSafari =
          /Safari/.test(userAgent) && !/Chrome|CriOS|Android|Edg\//.test(userAgent);
        const useNfcToolsRedirect = isSafari && !hasNfc;
        const NFC_TOOLS_SCHEME = "nfc-tools://";
        const NFC_TOOLS_STORE_URL = "https://apps.apple.com/en/app/nfc-tools/id1252962749";

        const workflows = {
          encrypt: initWorkflow("workflow-encrypt", {
            nextLabel: (stepIndex, totalSteps) => {
              if (stepIndex === 2) return "Encrypt";
              if (stepIndex >= totalSteps - 1) return "Done";
              return "Next";
            },
            onNext: ({ currentStep, nextButton }) => {
              if (currentStep === 2) {
                handleEncrypt({ triggerButton: nextButton });
                return true;
              }
              return false;
            },
          }),
          decrypt: initWorkflow("workflow-decrypt", {
            nextLabel: (stepIndex, totalSteps) => {
              if (stepIndex === totalSteps - 2) return "Decrypt";
              if (stepIndex >= totalSteps - 1) return "Done";
              return "Next";
            },
            onNext: ({ currentStep, nextButton, panels }) => {
              const activePanel = panels[currentStep];
              if (activePanel?.id === "decrypt-step-2") {
                handleDecrypt({ triggerButton: nextButton });
                return true;
              }
              return false;
            },
          }),
        };

        const tabButtons = Array.from(document.querySelectorAll("[data-tab-target]"));
        const tabPanels = Array.from(elements.tabPanels.querySelectorAll(".tab-panel"));
        let activeTab = elements.tabPanels.dataset.activeTab || "encrypt";
        const bestPracticesTriggers = Array.from(
          document.querySelectorAll("[data-best-practices-trigger]"),
        );
        const settingsButtons = Array.from(document.querySelectorAll("[data-settings-trigger]"));
        let settingsPanelOpen = false;
        let lastSettingsTrigger = null;
        const bestPracticesState = {
          open: false,
          lastTrigger: null,
        };
        elements.bestPracticesDialog.setAttribute("aria-hidden", "true");

        function positionSettingsPanel(trigger) {
          const panel = elements.advancedSettings;
          if (!panel) return;
          const reference = trigger instanceof HTMLElement ? trigger : null;
          panel.style.visibility = "hidden";
          panel.style.top = "0px";
          panel.style.left = "0px";
          requestAnimationFrame(() => {
            if (!settingsPanelOpen) return;
            const panelRect = panel.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const targetRect = reference?.getBoundingClientRect() ?? null;
            let top = viewportHeight / 2 - panelRect.height / 2;
            let left = viewportWidth / 2 - panelRect.width / 2;
            if (targetRect) {
              top = targetRect.bottom + 12;
              left = targetRect.left + targetRect.width / 2 - panelRect.width / 2;
            }
            top = Math.min(
              Math.max(16, top),
              viewportHeight - panelRect.height - 16,
            );
            left = Math.min(
              Math.max(16, left),
              viewportWidth - panelRect.width - 16,
            );
            const pointerCenter = targetRect
              ? targetRect.left + targetRect.width / 2
              : left + panelRect.width / 2;
            const pointerOffset = Math.max(
              18,
              Math.min(panelRect.width - 18, pointerCenter - left),
            );
            panel.style.setProperty("--pointer-offset", `${Math.round(pointerOffset)}px`);
            panel.style.top = `${Math.round(top)}px`;
            panel.style.left = `${Math.round(left)}px`;
            panel.style.visibility = "visible";
          });
        }

        function setSettingsPanelVisible(visible, options = {}) {
          settingsPanelOpen = Boolean(visible);
          elements.advancedSettingsLayer.hidden = !settingsPanelOpen;
          elements.advancedSettingsLayer.classList.toggle("is-open", settingsPanelOpen);
          elements.advancedSettings.hidden = !settingsPanelOpen;
          elements.advancedSettings.setAttribute("aria-hidden", settingsPanelOpen ? "false" : "true");
          settingsButtons.forEach((button) => {
            button.setAttribute("aria-expanded", settingsPanelOpen ? "true" : "false");
          });
          if (settingsPanelOpen) {
            positionSettingsPanel(options.trigger ?? lastSettingsTrigger);
            elements.advancedSettings.focus();
          } else {
            elements.advancedSettings.style.visibility = "";
            elements.advancedSettings.style.top = "";
            elements.advancedSettings.style.left = "";
            elements.advancedSettings.style.removeProperty("--pointer-offset");
            if (lastSettingsTrigger instanceof HTMLElement) {
              lastSettingsTrigger.focus();
            }
          }
        }

        function setBestPracticesVisible(visible, options = {}) {
          bestPracticesState.open = Boolean(visible);
          if (bestPracticesState.open && options.trigger instanceof HTMLElement) {
            bestPracticesState.lastTrigger = options.trigger;
          }
          elements.bestPracticesLayer.hidden = !bestPracticesState.open;
          elements.bestPracticesLayer.classList.toggle("is-open", bestPracticesState.open);
          elements.bestPracticesDialog.setAttribute(
            "aria-hidden",
            bestPracticesState.open ? "false" : "true",
          );
          if (bestPracticesState.open) {
            requestAnimationFrame(() => {
              elements.bestPracticesDialog.focus();
            });
          } else {
            const trigger = bestPracticesState.lastTrigger;
            if (trigger instanceof HTMLElement) {
              trigger.focus();
            }
          }
        }

        function setStatus(message, tone = "info") {
          elements.status.textContent = message;
          const toneStyles = {
            error: { color: "#fecaca", background: "rgba(248, 113, 113, 0.16)" },
            success: { color: "#bbf7d0", background: "rgba(34, 197, 94, 0.16)" },
            info: { color: "rgba(191, 219, 254, 0.95)", background: "rgba(59, 130, 246, 0.18)" },
          };
          const { color, background } = toneStyles[tone] ?? toneStyles.info;
          elements.status.style.color = color;
          elements.status.style.background = background;
          elements.status.hidden = false;
        }

        function getNfcErrorMessage(err, action = "write") {
          const fallback =
            action === "read"
              ? "Unable to read from NFC tag. Try again."
              : "Unable to write to NFC tag. Try again.";
          if (!err) return fallback;
          const name = typeof err === "object" && err && "name" in err ? String(err.name) : "";
          if (name === "NotAllowedError") {
            return "Browser denied NFC access. Allow NFC permissions and try again.";
          }
          if (name === "AbortError") {
            return action === "read"
              ? "NFC read cancelled. Keep the tag steady and try again."
              : "NFC write cancelled. Keep the tag steady and try again.";
          }
          if (name === "NotSupportedError") {
            return "This device does not support Web NFC.";
          }
          if (name === "SecurityError") {
            return "Web NFC requires a secure context (HTTPS).";
          }
          const message =
            typeof err === "object" && err && "message" in err && typeof err.message === "string"
              ? err.message.trim()
              : "";
          if (message) {
            const cleaned = message.replace(/errror/gi, "error").replace(/: null\b/gi, "").trim();
            if (/IO error/i.test(cleaned)) {
              return action === "read"
                ? "NFC tag reported an I/O error while reading. Reposition or try a different tag."
                : "NFC tag reported an I/O error while writing. Reposition or try a different tag.";
            }
            return cleaned;
          }
          return fallback;
        }

        function openNfcToolsApp(action = "write") {
          const verb = action === "read" ? "read from" : "write to";
          setStatus(`Opening App Store to ${verb} tags with NFC Tools…`, "info");
          window.location.href = NFC_TOOLS_STORE_URL;
        }

        function maybeRedirectToNfcTools(action) {
          if (!useNfcToolsRedirect) return false;
          openNfcToolsApp(action);
          return true;
        }

        function positionStatusForPanel(activePanel) {
          const shouldAttach = activeTab === "encrypt" || activeTab === "decrypt";
          if (!shouldAttach) {
            elements.status.hidden = true;
            return;
          }
          const header = activePanel?.querySelector(".section-header");
          if (header) {
            header.insertAdjacentElement("afterend", elements.status);
            elements.status.hidden = false;
          }
        }

        const nfcDialogState = {
          open: false,
          dismissible: false,
          autoCloseTimer: null,
          lastFocused: null,
        };

        function clearNfcDialogAutoClose() {
          if (nfcDialogState.autoCloseTimer !== null) {
            clearTimeout(nfcDialogState.autoCloseTimer);
            nfcDialogState.autoCloseTimer = null;
          }
        }

        function showNfcDialog({
          title,
          message,
          tone = "info",
          busy = false,
          dismissible = false,
          autoCloseMs = null,
        } = {}) {
          clearNfcDialogAutoClose();
          if (!nfcDialogState.open) {
            const activeElement = document.activeElement;
            nfcDialogState.lastFocused =
              activeElement instanceof HTMLElement ? activeElement : null;
          }
          if (typeof title === "string") {
            elements.nfcDialogTitle.textContent = title;
          }
          if (typeof message === "string") {
            elements.nfcDialogMessage.textContent = message;
          } else if (!elements.nfcDialogMessage.textContent) {
            elements.nfcDialogMessage.textContent = "";
          }

          elements.nfcDialog.dataset.tone = tone;
          elements.nfcDialog.dataset.busy = busy ? "true" : "false";
          elements.nfcDialog.setAttribute("aria-busy", busy ? "true" : "false");
          elements.nfcDialogSpinner.setAttribute("aria-hidden", busy ? "false" : "true");

          nfcDialogState.dismissible = Boolean(dismissible);
          elements.nfcDialogClose.hidden = !dismissible;
          elements.nfcDialogDismiss.hidden = !dismissible;
          elements.nfcDialogClose.tabIndex = dismissible ? 0 : -1;
          elements.nfcDialogDismiss.tabIndex = dismissible ? 0 : -1;
          elements.nfcDialogClose.setAttribute("aria-hidden", dismissible ? "false" : "true");
          elements.nfcDialogDismiss.setAttribute("aria-hidden", dismissible ? "false" : "true");

          elements.nfcDialogLayer.hidden = false;
          nfcDialogState.open = true;
          requestAnimationFrame(() => {
            elements.nfcDialog.focus();
          });

          if (typeof autoCloseMs === "number" && autoCloseMs > 0) {
            nfcDialogState.autoCloseTimer = window.setTimeout(() => {
              hideNfcDialog();
            }, autoCloseMs);
          }
        }

        function hideNfcDialog() {
          if (!nfcDialogState.open) return;
          clearNfcDialogAutoClose();
          elements.nfcDialogLayer.hidden = true;
          nfcDialogState.open = false;
          nfcDialogState.dismissible = false;
          elements.nfcDialog.dataset.busy = "false";
          elements.nfcDialog.setAttribute("aria-busy", "false");
          elements.nfcDialogSpinner.setAttribute("aria-hidden", "true");
          const focusTarget = nfcDialogState.lastFocused;
          nfcDialogState.lastFocused = null;
          if (focusTarget && typeof focusTarget.focus === "function" && focusTarget.isConnected) {
            focusTarget.focus();
          }
        }

        elements.nfcDialogClose.addEventListener("click", () => {
          if (nfcDialogState.dismissible) {
            hideNfcDialog();
          }
        });
        elements.nfcDialogDismiss.addEventListener("click", () => {
          if (nfcDialogState.dismissible) {
            hideNfcDialog();
          }
        });
        elements.nfcDialog.addEventListener("click", (event) => {
          event.stopPropagation();
        });
        elements.nfcDialogLayer.addEventListener("click", (event) => {
          if (event.target === elements.nfcDialogLayer && nfcDialogState.dismissible) {
            hideNfcDialog();
          }
        });

        function toBase64(u8) {
          const CHUNK_SIZE = 0x8000;
          let binary = "";
          for (let i = 0; i < u8.length; i += CHUNK_SIZE) {
            const chunk = u8.subarray(i, i + CHUNK_SIZE);
            binary += String.fromCharCode(...chunk);
          }
          return btoa(binary);
        }

        function fromBase64(str) {
          const binary = atob(str);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        }

        function encodeUtf8(s) {
          return new TextEncoder().encode(s);
        }

        function decodeUtf8(bytes) {
          return new TextDecoder().decode(bytes);
        }

        function dataViewToString(data) {
          if (data instanceof DataView) {
            return new TextDecoder().decode(
              new Uint8Array(data.buffer, data.byteOffset, data.byteLength),
            );
          }
          if (data instanceof ArrayBuffer) {
            return new TextDecoder().decode(new Uint8Array(data));
          }
          if (data instanceof Uint8Array) {
            return new TextDecoder().decode(data);
          }
          if (typeof data === "string") {
            return data;
          }
          return "";
        }

        async function computeDigestBase64(bytes) {
          const digestBuffer = await crypto.subtle.digest("SHA-256", bytes);
          return toBase64(new Uint8Array(digestBuffer));
        }

        function updateAdvancedSummary() {
          const { threshold, total } = advancedState;
          if (advancedState.enabled) {
            elements.advancedSettings.classList.add("advanced-settings--expanded");
            elements.advancedSettingsFields.hidden = false;
            elements.advancedSummary.hidden = false;
            elements.advancedSummary.textContent = `Any ${threshold} of ${total} keys will unlock the ciphertext.`;
            elements.advancedDescription.hidden = true;
          } else {
            elements.advancedSettings.classList.remove("advanced-settings--expanded");
            elements.advancedSettingsFields.hidden = true;
            elements.advancedSummary.hidden = true;
            elements.advancedDescription.hidden = false;
            elements.advancedSummary.textContent = "";
          }
          elements.shamirDecryptHelper.textContent = advancedState.enabled
            ? `Import any ${threshold} of ${total} keys to rebuild the encrypted blob automatically.`
            : "Import any K of N keys to rebuild the encrypted blob automatically.";
          elements.advancedToggle.setAttribute("aria-pressed", advancedState.enabled ? "true" : "false");
          elements.advancedToggle.textContent = advancedState.enabled ? "ON" : "OFF";
          elements.advancedThreshold.value = String(advancedState.threshold);
          elements.advancedTotal.value = String(advancedState.total);
          settingsButtons.forEach((button) => {
            button.setAttribute("aria-pressed", advancedState.enabled ? "true" : "false");
          });
          if (settingsPanelOpen) {
            positionSettingsPanel(lastSettingsTrigger);
          }
        }

        function updateShamirStepMessage() {
          if (!advancedState.enabled) {
            elements.shamirStepMessage.hidden = false;
            elements.shamirStepMessage.textContent =
              "Enable advanced mode to split the ciphertext into multiple recovery keys.";
            return;
          }
          const shareCount = advancedState.lastShares?.shares?.length ?? 0;
          if (shareCount > 0) {
            const plural = shareCount === 1 ? "" : "s";
            elements.shamirStepMessage.hidden = false;
            const meta = advancedState.lastShares ?? {
              threshold: advancedState.threshold,
              total: advancedState.total,
            };
            elements.shamirStepMessage.textContent = `Generated ${shareCount} recovery key${plural}. Any ${meta.threshold} of ${meta.total} will restore the ciphertext.`;
          } else {
            elements.shamirStepMessage.hidden = false;
            elements.shamirStepMessage.textContent =
              "Encrypt to generate recovery keys. They will appear below.";
          }
        }

        function syncAdvancedInputs(options = {}) {
          let total = Number.parseInt(elements.advancedTotal.value, 10);
          let threshold = Number.parseInt(elements.advancedThreshold.value, 10);
          if (!Number.isFinite(total)) {
            total = SHAMIR_DEFAULT_TOTAL;
          }
          if (!Number.isFinite(threshold)) {
            threshold = SHAMIR_DEFAULT_THRESHOLD;
          }
          total = Math.max(2, Math.min(SHAMIR_MAX_SHARES, total));
          threshold = Math.max(2, Math.min(SHAMIR_MAX_SHARES, threshold));
          if (threshold > total) {
            threshold = total;
          }
          advancedState.total = total;
          advancedState.threshold = threshold;
          elements.advancedTotal.value = String(total);
          elements.advancedThreshold.value = String(threshold);
          updateAdvancedSummary();
          if (options.report && advancedState.enabled) {
            setStatus(`Advanced mode set to ${threshold} of ${total} keys.`, "info");
          }
        }

        function resetEncryptedShares() {
          advancedState.lastShares = null;
          elements.shamirShareList.innerHTML = "";
          elements.shamirEncryptSection.hidden = true;
          updateShamirStepMessage();
        }

        function renderShareCards() {
          const data = advancedState.lastShares;
          const container = elements.shamirShareList;
          container.innerHTML = "";
          if (!advancedState.enabled || !data) {
            elements.shamirEncryptSection.hidden = true;
            updateShamirStepMessage();
            return;
          }
          elements.shamirEncryptSection.hidden = false;
          data.shares.forEach((share, index) => {
            const card = document.createElement("article");
            card.className = "share-card";
            card.dataset.shareIndex = String(index);

            const header = document.createElement("header");
            header.textContent = `Key ${share.x} of ${data.total}`;
            card.appendChild(header);

            const textarea = document.createElement("textarea");
            textarea.readOnly = true;
            textarea.value = share.text;
            card.appendChild(textarea);

            const controls = document.createElement("div");
            controls.className = "controls";

            const copyBtn = document.createElement("button");
            copyBtn.type = "button";
            copyBtn.className = "action-btn secondary";
            copyBtn.dataset.shareAction = "copy";
            copyBtn.dataset.shareIndex = String(index);
            copyBtn.textContent = "Copy";
            controls.appendChild(copyBtn);

            const downloadBtn = document.createElement("button");
            downloadBtn.type = "button";
            downloadBtn.className = "action-btn secondary";
            downloadBtn.dataset.shareAction = "download";
            downloadBtn.dataset.shareIndex = String(index);
            downloadBtn.textContent = "Download as File";
            controls.appendChild(downloadBtn);

            const nfcBtn = document.createElement("button");
            nfcBtn.type = "button";
            nfcBtn.className = "action-btn secondary";
            nfcBtn.dataset.shareAction = "nfc";
            nfcBtn.dataset.shareIndex = String(index);
            nfcBtn.textContent = "Write to NFC";
            if (!hasNfc) {
              nfcBtn.disabled = true;
              nfcBtn.title = "Web NFC is not supported on this device.";
            }
            controls.appendChild(nfcBtn);

            card.appendChild(controls);
            container.appendChild(card);
          });
          updateShamirStepMessage();
        }

        function downloadAsFile(text, filename) {
          const blob = new Blob([text], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }

        async function writeJsonRecordToNfc(payload, messages = {}) {
          if (maybeRedirectToNfcTools("write")) {
            return;
          }
          if (!hasNfc) {
            throw new Error("Web NFC is not supported on this device.");
          }
          const progressMessage = messages.progress ?? "Bring an NFC tag close to write…";
          const successMessage = messages.success ?? "Data written to NFC tag.";
          const title = messages.title ?? "Writing to NFC";
          const autoCloseMs =
            typeof messages.autoCloseMs === "number" && messages.autoCloseMs > 0
              ? messages.autoCloseMs
              : 1800;
          if (!payload || !payload.trim()) {
            throw new Error("Nothing to write to NFC.");
          }
          showNfcDialog({
            title,
            message: progressMessage,
            tone: "info",
            busy: true,
            dismissible: false,
          });
          const ndef = new NDEFReader();
          const data = encodeUtf8(payload);
          try {
            await ndef.write({
              records: [
                {
                  recordType: "mime",
                  mediaType: "application/json",
                  data,
                },
              ],
            });
          } catch (err) {
            const friendly = getNfcErrorMessage(err, "write");
            showNfcDialog({
              title,
              message: friendly,
              tone: "error",
              busy: false,
              dismissible: true,
            });
            const error = new Error(friendly);
            if (err && typeof err === "object") {
              error.cause = err;
            }
            throw error;
          }
          showNfcDialog({
            title,
            message: successMessage,
            tone: "success",
            busy: false,
            dismissible: true,
            autoCloseMs,
          });
        }

        async function readJsonRecordFromNfc(messages = {}) {
          if (!hasNfc) {
            throw new Error("Web NFC is not supported on this device.");
          }
          const progressMessage = messages.progress ?? "Bring an NFC tag close to read…";
          const successMessage = messages.success ?? "Data read from NFC tag.";
          const title = messages.title ?? "Reading from NFC";
          const autoCloseMs =
            typeof messages.autoCloseMs === "number" && messages.autoCloseMs > 0
              ? messages.autoCloseMs
              : 1800;
          showNfcDialog({
            title,
            message: progressMessage,
            tone: "info",
            busy: true,
            dismissible: false,
          });
          const ndef = new NDEFReader();
          const readPromise = new Promise((resolve, reject) => {
            const onReading = (event) => {
              try {
                const records = event.message.records ?? [];
                if (!records.length) {
                  reject(new Error("No records found on tag."));
                  return;
                }
                const record = records[0];
                const payload = dataViewToString(record.data);
                if (!payload || typeof payload !== "string") {
                  reject(new Error("No readable data on tag."));
                  return;
                }
                resolve(payload);
              } catch (err) {
                reject(err);
              }
            };
            const onError = () => reject(new Error("Failed to read NFC tag."));
            ndef.addEventListener("reading", onReading, { once: true });
            ndef.addEventListener("readingerror", onError, { once: true });
          });
          try {
            await ndef.scan();
            const payload = await readPromise;
            showNfcDialog({
              title,
              message: successMessage,
              tone: "success",
              busy: false,
              dismissible: true,
              autoCloseMs,
            });
            return payload;
          } catch (err) {
            const friendly = getNfcErrorMessage(err, "read");
            showNfcDialog({
              title,
              message: friendly,
              tone: "error",
              busy: false,
              dismissible: true,
            });
            const error = new Error(friendly);
            if (err && typeof err === "object") {
              error.cause = err;
            }
            throw error;
          }
        }

        async function generateSharesForCiphertext(blobJson) {
          const bytes = encodeUtf8(blobJson);
          const shares = shamirSplit(bytes, advancedState.threshold, advancedState.total);
          const digest = await computeDigestBase64(bytes);
          const shareEntries = shares.map((share) => {
            const payload = {
              version: 1,
              scheme: "shamir",
              threshold: advancedState.threshold,
              total: advancedState.total,
              digest_b64: digest,
              x: share.x,
              data_b64: toBase64(share.y),
            };
            return {
              x: share.x,
              y: share.y,
              text: JSON.stringify(payload, null, 2),
            };
          });
          advancedState.lastShares = {
            threshold: advancedState.threshold,
            total: advancedState.total,
            digest,
            shares: shareEntries,
          };
          renderShareCards();
        }

        function resetDecryptShares() {
          advancedState.decrypt.shares = [];
          advancedState.decrypt.meta = null;
          advancedState.decrypt.combined = false;
          elements.shamirCollectedShares.innerHTML = "";
          elements.shamirShareInput.value = "";
          elements.shamirSharesNeeded.textContent = advancedState.enabled
            ? "No keys added yet."
            : "";
        }

        function renderCollectedShares() {
          const list = elements.shamirCollectedShares;
          list.innerHTML = "";
          advancedState.decrypt.shares
            .slice()
            .sort((a, b) => a.x - b.x)
            .forEach((share) => {
              const item = document.createElement("li");
              const label = document.createElement("span");
              label.textContent = `Key ${share.x} (${share.source ?? "imported"})`;
              item.appendChild(label);

              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.className = "action-btn secondary";
              removeBtn.dataset.shareRemove = String(share.x);
              removeBtn.textContent = "Remove";
              item.appendChild(removeBtn);
              list.appendChild(item);
            });
        }

        function updateSharesNeededMessage() {
          if (!advancedState.enabled) {
            elements.shamirSharesNeeded.textContent = "";
            return;
          }
          const meta = advancedState.decrypt.meta;
          if (!meta) {
            elements.shamirSharesNeeded.textContent = "No keys added yet.";
            return;
          }
          const have = advancedState.decrypt.shares.length;
          if (have === 0) {
            elements.shamirSharesNeeded.textContent = `Need ${meta.threshold} keys (of ${meta.total}) to restore the encrypted blob.`;
          } else if (have < meta.threshold) {
            elements.shamirSharesNeeded.textContent = `Need ${meta.threshold - have} more key(s) to reach the ${meta.threshold} threshold.`;
          } else {
            elements.shamirSharesNeeded.textContent =
              "Enough keys collected. The ciphertext field is populated automatically.";
          }
        }

        async function tryCombineShares() {
          const meta = advancedState.decrypt.meta;
          if (!meta) return;
          const shares = advancedState.decrypt.shares;
          if (shares.length < meta.threshold) {
            return;
          }
          try {
            const secret = shamirCombine(
              shares.map((share) => ({
                x: share.x,
                y: share.y,
              })),
            );
            const digest = await computeDigestBase64(secret);
            if (meta.digest && digest !== meta.digest) {
              throw new Error("Combined keys failed the integrity check.");
            }
            const ciphertext = decodeUtf8(secret);
            setCiphertext(ciphertext);
            updateSharesNeededMessage();
            if (!advancedState.decrypt.combined) {
              setStatus("Collected enough keys. Ciphertext restored.", "success");
              workflows.decrypt.setStep(2, { force: true });
            }
            advancedState.decrypt.combined = true;
          } catch (err) {
            console.error(err);
            setStatus(err instanceof Error ? err.message : "Failed to combine keys.", "error");
          }
        }

        function setAdvancedEnabled(enabled) {
          advancedState.enabled = Boolean(enabled);
          if (advancedState.enabled) {
            elements.shamirStepPanel.removeAttribute("data-step-skip");
            elements.shamirDecryptStep.removeAttribute("data-step-skip");
          } else {
            elements.shamirStepPanel.setAttribute("data-step-skip", "");
            elements.shamirDecryptStep.setAttribute("data-step-skip", "");
          }
          elements.shamirEncryptSection.hidden = !advancedState.enabled || !advancedState.lastShares;
          elements.shamirDecryptSection.hidden = !advancedState.enabled;
          if (!advancedState.enabled) {
            resetEncryptedShares();
            resetDecryptShares();
          } else {
            syncAdvancedInputs();
            updateSharesNeededMessage();
          }
          updateAdvancedSummary();
          updateShamirStepMessage();
          if (!advancedState.enabled && workflows.encrypt.currentStep > 3) {
            workflows.encrypt.setStep(3, { force: true });
          } else {
            workflows.encrypt.setStep(workflows.encrypt.currentStep, { force: true });
          }
          workflows.decrypt.setStep(0, { force: true });
        }

        function parseShareString(raw) {
          const trimmed = (raw ?? "").trim();
          if (!trimmed) {
            throw new Error("Key input is empty.");
          }
          let payload;
          try {
            payload = JSON.parse(trimmed);
          } catch {
            throw new Error("Key is not valid JSON.");
          }
          if (payload.version !== 1) {
            throw new Error("Unsupported key version.");
          }
          if (payload.scheme !== "shamir") {
            throw new Error("Unsupported key scheme.");
          }
          const threshold = Number(payload.threshold);
          const total = Number(payload.total);
          const x = Number(payload.x);
          if (!Number.isInteger(threshold) || threshold < 2) {
            throw new Error("Key threshold is invalid.");
          }
          if (!Number.isInteger(total) || total < threshold) {
            throw new Error("Key total is invalid.");
          }
          if (!Number.isInteger(x) || x <= 0 || x > 255) {
            throw new Error("Key index is out of range.");
          }
          if (typeof payload.data_b64 !== "string") {
            throw new Error("Key is missing share data.");
          }
          const data = fromBase64(payload.data_b64);
          if (!(data instanceof Uint8Array)) {
            throw new Error("Key data is invalid.");
          }
          const digest = typeof payload.digest_b64 === "string" ? payload.digest_b64 : null;
          return { x, threshold, total, digest, y: data, text: trimmed };
        }

        async function addShareFromString(raw, source) {
          try {
            const parsed = parseShareString(raw);
            const meta = advancedState.decrypt.meta;
            if (meta) {
              if (meta.threshold !== parsed.threshold || meta.total !== parsed.total) {
                throw new Error("Key thresholds do not match previously added keys.");
              }
              if (meta.digest && parsed.digest && meta.digest !== parsed.digest) {
                throw new Error("Key digest does not match previously added keys.");
              }
              if (!meta.digest && parsed.digest) {
                meta.digest = parsed.digest;
              }
            } else {
              advancedState.decrypt.meta = {
                threshold: parsed.threshold,
                total: parsed.total,
                digest: parsed.digest ?? null,
              };
            }
            if (advancedState.decrypt.shares.some((share) => share.x === parsed.x)) {
              throw new Error(`Key ${parsed.x} already added.`);
            }
            advancedState.decrypt.shares.push({
              x: parsed.x,
              y: parsed.y,
              text: parsed.text,
              source: source ?? "imported",
            });
            advancedState.decrypt.combined = false;
            renderCollectedShares();
            updateSharesNeededMessage();
            setStatus(`Key ${parsed.x} added.`, "success");
            await tryCombineShares();
          } catch (err) {
            console.error(err);
            setStatus(err instanceof Error ? err.message : "Failed to add key.", "error");
          }
        }

        function removeShareByX(x) {
          const index = advancedState.decrypt.shares.findIndex((share) => share.x === x);
          if (index === -1) return;
          advancedState.decrypt.shares.splice(index, 1);
          if (advancedState.decrypt.shares.length === 0) {
            advancedState.decrypt.meta = null;
          }
          advancedState.decrypt.combined = false;
          renderCollectedShares();
          updateSharesNeededMessage();
        }

        function parseIterations(value) {
          if (!value) return DEFAULT_ITERATIONS;
          const parsed = Number(value);
          if (!Number.isFinite(parsed) || parsed < MIN_ITERATIONS) {
            throw new Error(`Iterations must be a number ≥ ${MIN_ITERATIONS}.`);
          }
          return Math.floor(parsed);
        }

        async function deriveKey(passphrase, salt, iterations) {
          const baseKey = await crypto.subtle.importKey(
            "raw",
            encodeUtf8(passphrase),
            { name: "PBKDF2" },
            false,
            ["deriveKey"],
          );
          return await crypto.subtle.deriveKey(
            {
              name: "PBKDF2",
              hash: "SHA-256",
              salt,
              iterations,
            },
            baseKey,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"],
          );
        }

        async function encryptPlaintext(plaintext, passphrase, iterations) {
          if (!plaintext.trim()) throw new Error("Plaintext input is empty.");
          const salt = crypto.getRandomValues(new Uint8Array(16));
          const nonce = crypto.getRandomValues(new Uint8Array(12));
          const key = await deriveKey(passphrase, salt, iterations);

          const ciphertext = new Uint8Array(
            await crypto.subtle.encrypt(
              { name: "AES-GCM", iv: nonce },
              key,
              encodeUtf8(plaintext),
            ),
          );

          const blob = {
            version: 1,
            kdf: "PBKDF2",
            hash: "SHA-256",
            iterations,
            salt_b64: toBase64(salt),
            nonce_b64: toBase64(nonce),
            ciphertext_b64: toBase64(ciphertext),
          };

          return JSON.stringify(blob, null, 2);
        }

        async function decryptBlob(blobJson, passphrase) {
          if (!blobJson.trim()) throw new Error("Encrypted blob input is empty.");
          const blob = JSON.parse(blobJson);

          if (blob.kdf !== "PBKDF2" || blob.hash !== "SHA-256") {
            throw new Error("Unsupported KDF parameters.");
          }

          const salt = fromBase64(blob.salt_b64);
          const nonce = fromBase64(blob.nonce_b64);
          const ciphertext = fromBase64(blob.ciphertext_b64);
          const key = await deriveKey(passphrase, salt, blob.iterations);

          const plaintextBytes = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: nonce },
            key,
            ciphertext,
          );
          return decodeUtf8(new Uint8Array(plaintextBytes));
        }

        function setCiphertext(value) {
          const normalized = value ?? "";
          elements.ciphertextEncrypt.value = normalized;
          elements.ciphertextDecrypt.value = normalized;
        }

        function syncCiphertext(source, target) {
          source.addEventListener("input", () => {
            if (target.value !== source.value) {
              target.value = source.value;
            }
          });
        }

        syncCiphertext(elements.ciphertextEncrypt, elements.ciphertextDecrypt);
        syncCiphertext(elements.ciphertextDecrypt, elements.ciphertextEncrypt);

        function getPassphraseForEncrypt() {
          const pw = elements.encryptPassphrase.value;
          const confirm = elements.encryptPassphraseConfirm.value;

          if (!pw && !confirm) {
            return "";
          }
          if (!pw && confirm) {
            throw new Error("Enter a passphrase to match the confirmation.");
          }
          if (pw && !confirm) {
            throw new Error("Confirm the passphrase to continue.");
          }
          if (pw.length < 4) {
            throw new Error("Passphrase must be at least 4 characters.");
          }
          if (pw !== confirm) {
            throw new Error("Passphrases do not match.");
          }
          return pw;
        }

        function getPassphraseForDecrypt() {
          return elements.decryptPassphrase.value;
        }

        function setTab(tabName, options = {}) {
          const target = tabName || activeTab;
          const panel = tabPanels.find((panelEl) => panelEl.dataset.tab === target);
          if (!panel) return;

          activeTab = panel.dataset.tab;
          elements.tabPanels.dataset.activeTab = activeTab;

          tabPanels.forEach((panelEl) => {
            const isActive = panelEl.dataset.tab === activeTab;
            panelEl.classList.toggle("tab-panel--active", isActive);
            panelEl.setAttribute("aria-hidden", isActive ? "false" : "true");
          });

          tabButtons.forEach((button) => {
            const isActive = button.dataset.tabTarget === activeTab;
            button.classList.toggle("tab-btn--active", isActive);
            button.setAttribute("aria-selected", isActive ? "true" : "false");
            button.setAttribute("tabindex", isActive ? "0" : "-1");
            if (isActive && options.focusButton) {
              button.focus();
            }
          });

          positionStatusForPanel(panel);
        }

        tabButtons.forEach((button, index) => {
          button.addEventListener("click", () => {
            setTab(button.dataset.tabTarget || activeTab);
          });
          button.addEventListener("keydown", (event) => {
            if (event.key === "ArrowRight" || event.key === "ArrowLeft") {
              event.preventDefault();
              const direction = event.key === "ArrowRight" ? 1 : -1;
              const nextIndex = (index + direction + tabButtons.length) % tabButtons.length;
              const nextButton = tabButtons[nextIndex];
              setTab(nextButton.dataset.tabTarget || activeTab, { focusButton: true });
            }
          });
        });

        setTab(activeTab);

        bestPracticesTriggers.forEach((button) => {
          button.addEventListener("click", (event) => {
            event.preventDefault();
            setBestPracticesVisible(true, { trigger: button });
          });
        });

        elements.bestPracticesClose.addEventListener("click", () => {
          setBestPracticesVisible(false);
        });

        elements.bestPracticesLayer.addEventListener("click", (event) => {
          if (event.target === elements.bestPracticesLayer) {
            setBestPracticesVisible(false);
          }
        });

        settingsButtons.forEach((button) => {
          button.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            lastSettingsTrigger = button;
            setSettingsPanelVisible(!settingsPanelOpen, { trigger: button });
          });
        });

        document.addEventListener("click", (event) => {
          if (!settingsPanelOpen) return;
          const target = event.target;
          if (!(target instanceof Node)) return;
          const interactingWithTrigger = settingsButtons.some(
            (button) => button === target || button.contains(target),
          );
          if (interactingWithTrigger) {
            return;
          }
          if (!elements.advancedSettings.contains(target)) {
            setSettingsPanelVisible(false);
          }
        });

        elements.advancedSettingsLayer.addEventListener("click", (event) => {
          if (event.target === elements.advancedSettingsLayer) {
            setSettingsPanelVisible(false);
          }
        });

        document.addEventListener("keydown", (event) => {
          if (event.key !== "Escape") return;
          if (nfcDialogState.open && nfcDialogState.dismissible) {
            event.preventDefault();
            hideNfcDialog();
            return;
          }
          if (bestPracticesState.open) {
            event.preventDefault();
            setBestPracticesVisible(false);
            return;
          }
          if (settingsPanelOpen) {
            setSettingsPanelVisible(false);
          }
        });

        const repositionSettingsPanel = () => {
          if (settingsPanelOpen) {
            positionSettingsPanel(lastSettingsTrigger);
          }
        };
        window.addEventListener("resize", repositionSettingsPanel);
        window.addEventListener("scroll", repositionSettingsPanel, true);

        setSettingsPanelVisible(false);
        syncAdvancedInputs();
        setAdvancedEnabled(false);

        elements.advancedToggle.addEventListener("click", () => {
          setAdvancedEnabled(!advancedState.enabled);
        });

        const advancedInputHandler = () => syncAdvancedInputs({ report: advancedState.enabled });
        elements.advancedThreshold.addEventListener("change", advancedInputHandler);
        elements.advancedTotal.addEventListener("change", advancedInputHandler);
        elements.advancedThreshold.addEventListener("input", () => syncAdvancedInputs());
        elements.advancedTotal.addEventListener("input", () => syncAdvancedInputs());

        elements.shamirShareList.addEventListener("click", async (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const button = target.closest("[data-share-action]");
          if (!(button instanceof HTMLElement)) return;
          if (!advancedState.enabled) {
            setStatus("Enable advanced mode to use split keys.", "error");
            return;
          }
          const index = Number.parseInt(button.dataset.shareIndex ?? "", 10);
          if (!Number.isInteger(index) || index < 0) return;
          const shareData = advancedState.lastShares?.shares?.[index];
          if (!shareData) return;
          const action = button.dataset.shareAction;
          if (action === "nfc") {
            if (maybeRedirectToNfcTools("write")) return;
            try {
              await writeJsonRecordToNfc(shareData.text, {
                title: `Write key ${shareData.x} to NFC`,
                progress: `Bring an NFC tag close to write key ${shareData.x}…`,
                success: `Key ${shareData.x} written to NFC.`,
              });
            } catch (err) {
              console.error(err);
            }
            return;
          }
          try {
            if (action === "copy") {
              await navigator.clipboard.writeText(shareData.text);
              setStatus(`Key ${shareData.x} copied to clipboard.`, "success");
            } else if (action === "download") {
              downloadAsFile(
                shareData.text,
                `recoveryware-key-${shareData.x}-of-${advancedState.lastShares.total}.json`,
              );
              setStatus(`Key ${shareData.x} downloaded.`, "success");
            }
          } catch (err) {
            console.error(err);
            setStatus(
              err instanceof Error ? err.message : "Failed to process key action.",
              "error",
            );
          }
        });

        elements.shamirAddShareBtn.addEventListener("click", async () => {
          if (!advancedState.enabled) {
            setStatus("Enable advanced mode to import keys.", "error");
            return;
          }
          const raw = elements.shamirShareInput.value;
          if (!raw.trim()) {
            setStatus("Paste a key JSON blob first.", "error");
            return;
          }
          await addShareFromString(raw, "pasted");
          elements.shamirShareInput.value = "";
        });

        elements.shamirClearSharesBtn.addEventListener("click", () => {
          if (!advancedState.enabled) return;
          const hadShares = advancedState.decrypt.shares.length > 0;
          resetDecryptShares();
          if (hadShares) {
            setStatus("Cleared imported keys.", "info");
          }
        });

        elements.shamirUploadBtn.addEventListener("click", () => {
          if (!advancedState.enabled) {
            setStatus("Enable advanced mode to import keys.", "error");
            return;
          }
          elements.shamirUploadInput.click();
        });

        elements.shamirUploadInput.addEventListener("change", async () => {
          if (!advancedState.enabled) {
            elements.shamirUploadInput.value = "";
            return;
          }
          const files = Array.from(elements.shamirUploadInput.files ?? []);
          elements.shamirUploadInput.value = "";
          if (!files.length) return;
          for (const file of files) {
            try {
              const text = await file.text();
              await addShareFromString(text, file.name || "file");
            } catch (err) {
              console.error(err);
              setStatus(
                err instanceof Error ? `${file.name}: ${err.message}` : "Failed to import key file.",
                "error",
              );
            }
          }
        });

        elements.shamirReadShareNfcBtn.addEventListener("click", async () => {
          if (!advancedState.enabled) {
            setStatus("Enable advanced mode to import keys.", "error");
            return;
          }
          if (maybeRedirectToNfcTools("read")) return;
          if (!hasNfc) {
            setStatus("Web NFC not supported on this device.", "error");
            return;
          }
          let payload;
          try {
            payload = await readJsonRecordFromNfc({
              title: "Read split key from NFC",
              progress: "Bring an NFC tag close to read a key…",
              success: "Key JSON read from NFC tag.",
            });
          } catch (err) {
            console.error(err);
            return;
          }
          await addShareFromString(payload, "NFC");
        });

        elements.shamirCollectedShares.addEventListener("click", (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const button = target.closest("[data-share-remove]");
          if (!(button instanceof HTMLElement)) return;
          const x = Number.parseInt(button.dataset.shareRemove ?? "", 10);
          if (!Number.isInteger(x)) return;
          removeShareByX(x);
          if (advancedState.decrypt.shares.length === 0) {
            setStatus("Removed key. No keys remaining.", "info");
          } else {
            setStatus(`Removed key ${x}.`, "info");
            tryCombineShares();
          }
        });

        async function handleEncrypt(options = {}) {
          const triggerButton = options.triggerButton ?? null;
          const originalLabel = triggerButton?.textContent;
          let shouldRestoreButton = Boolean(triggerButton);
          if (triggerButton) {
            triggerButton.disabled = true;
            if (originalLabel) {
              triggerButton.textContent = "Encrypting…";
            }
          }
          try {
            setStatus("Encrypting…");
            const passphrase = getPassphraseForEncrypt();
            const iterations = parseIterations(elements.iterations.value);
            const plaintext = elements.encryptPlaintext.value;
            const blobJson = await encryptPlaintext(plaintext, passphrase, iterations);
            setCiphertext(blobJson);
            if (advancedState.enabled) {
              await generateSharesForCiphertext(blobJson);
              setStatus("Encryption complete. Generated split keys.", "success");
            } else {
              resetEncryptedShares();
              setStatus("Encryption complete.", "success");
            }
            const targetStep = advancedState.enabled ? 4 : 3;
            workflows.encrypt.setStep(targetStep, { force: true });
            shouldRestoreButton = false;
          } catch (err) {
            console.error(err);
            setStatus(err instanceof Error ? err.message : String(err), "error");
          } finally {
            if (triggerButton && shouldRestoreButton) {
              triggerButton.disabled = false;
              if (originalLabel) {
                triggerButton.textContent = originalLabel;
              }
            }
          }
        }

        async function handleDecrypt(options = {}) {
          if (options instanceof Event) {
            options.preventDefault?.();
            options = {};
          }
          const triggerButton = options.triggerButton ?? null;
          const originalLabel = triggerButton?.textContent;
          let shouldRestoreButton = Boolean(triggerButton);
          if (triggerButton) {
            triggerButton.disabled = true;
            if (originalLabel) {
              triggerButton.textContent = "Decrypting…";
            }
          }
          try {
            setStatus("Decrypting…");
            const passphrase = getPassphraseForDecrypt();
            const blobJson = elements.ciphertextDecrypt.value;
            const plaintext = await decryptBlob(blobJson, passphrase);
            elements.decryptPlaintext.value = plaintext;
            elements.encryptPlaintext.value = plaintext;
            workflows.decrypt.setStep(3, { force: true });
            setStatus("Decryption complete.", "success");
            shouldRestoreButton = false;
          } catch (err) {
            console.error(err);
            setStatus(err instanceof Error ? err.message : String(err), "error");
          } finally {
            if (triggerButton && shouldRestoreButton) {
              triggerButton.disabled = false;
              if (originalLabel) {
                triggerButton.textContent = originalLabel;
              }
            }
          }
        }

        async function handleWriteNfc() {
          if (maybeRedirectToNfcTools("write")) return;
          if (!hasNfc) {
            setStatus("Web NFC not supported on this device.", "error");
            return;
          }
          const blobJson = elements.ciphertextEncrypt.value.trim();
          if (!blobJson) {
            setStatus("Encrypt text first before writing to NFC.", "error");
            return;
          }
          try {
            await writeJsonRecordToNfc(blobJson, {
              title: "Write encrypted blob to NFC",
              progress: "Bring an NFC tag close to write…",
              success: "Encrypted blob written to NFC tag.",
            });
          } catch (err) {
            console.error(err);
          }
        }

        elements.copyCiphertextBtn.addEventListener("click", async () => {
          const data = elements.ciphertextEncrypt.value.trim();
          if (!data) {
            setStatus("No encrypted data to copy.", "error");
            return;
          }
          try {
            await navigator.clipboard.writeText(data);
            setStatus("Encrypted blob copied to clipboard.", "success");
          } catch (err) {
            console.error(err);
            setStatus("Clipboard write failed. Copy manually.", "error");
          }
        });

        elements.downloadCiphertextBtn.addEventListener("click", () => {
          const data = elements.ciphertextEncrypt.value.trim();
          if (!data) {
            setStatus("No encrypted data to download.", "error");
            return;
          }
          try {
            downloadAsFile(data, "recoveryware-encrypted.json");
            setStatus("Encrypted blob downloaded.", "success");
          } catch (err) {
            console.error(err);
            setStatus("Download failed. Copy manually.", "error");
          }
        });

        elements.pasteCiphertextBtn.addEventListener("click", async () => {
          try {
            const text = await navigator.clipboard.readText();
            if (!text.trim()) {
              setStatus("Clipboard does not contain any text.", "error");
              return;
            }
            setCiphertext(text.trim());
            setTab("decrypt");
            workflows.decrypt.setStep(1, { force: true });
            setStatus("Encrypted blob pasted from clipboard.", "success");
          } catch (err) {
            console.error(err);
            setStatus("Clipboard read failed. Paste manually instead.", "error");
          }
        });

        async function handleReadNfc() {
          if (maybeRedirectToNfcTools("read")) return;
          if (!hasNfc) {
            setStatus("Web NFC not supported on this device.", "error");
            return;
          }
          let payload;
          try {
            payload = await readJsonRecordFromNfc({
              title: "Read encrypted blob from NFC",
              progress: "Bring an NFC tag close to read…",
              success: "Encrypted blob loaded from NFC tag.",
            });
          } catch (err) {
            console.error(err);
            return;
          }
          setCiphertext(payload);
          setTab("decrypt");
          workflows.decrypt.setStep(1, { force: true });
        }

        elements.writeNfcBtn.addEventListener("click", handleWriteNfc);
        elements.readNfcBtn.addEventListener("click", handleReadNfc);

        if (!hasNfc) {
          if (useNfcToolsRedirect) {
            elements.writeNfcBtn.disabled = false;
            elements.writeNfcBtn.title = "Opens NFC Tools to write tags.";
            elements.readNfcBtn.disabled = false;
            elements.readNfcBtn.title = "Opens NFC Tools to read tags.";
            elements.shamirReadShareNfcBtn.disabled = false;
            elements.shamirReadShareNfcBtn.title = "Opens NFC Tools to read tags.";
          } else {
            elements.writeNfcBtn.disabled = true;
            elements.writeNfcBtn.title = "Web NFC is only available on supported Android browsers.";
            elements.readNfcBtn.disabled = true;
            elements.readNfcBtn.title = "Web NFC is only available on supported Android browsers.";
            elements.shamirReadShareNfcBtn.disabled = true;
            elements.shamirReadShareNfcBtn.title =
              "Web NFC is only available on supported Android browsers.";
          }
        }

        setStatus("Ready.");
      });
    </script>
  </body>
</html>
